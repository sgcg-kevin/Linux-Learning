Linux系统入门

Linux系统管理
	磁盘管理、文件系统管理
	RAID基础原理、LVM2
	网络管理：TCP/IP协议、Linux网络属性配置
	程序包管理：rpm, yum
	进程管理：htop, glance, tsar等
	sed和awk
	Linux系统开机流程
	内核管理基础知识：编译内核、模块
	Linux系统裁剪
		kernel+busybox
	课外作业：LFS

回顾：find、特殊权限、if语句

Linux磁盘管理

	I/O Ports: I/O设备地址；

	一切皆文件：
		open(), read(), write(), close()

		块设备：block，存取单位“块”，磁盘
		字符设备：char，存取单位“字符”，键盘

		设备文件：关联至一个设备驱动程序，进而能够跟与之对应硬件设备进行通信；

			设备号码：
				主设备号：major number, 标识设备类型
				次设备号：minor number, 标识同一类型下的不同设备

			硬盘接口类型：
				并行：
					IDE：133MB/s
					SCSI：640MB/s
				串口：
					SATA：6Gbps
					SAS：6Gbps
					USB：480MB/s

					rpm: rotations per minute


			/dev/DEV_FILE
				磁盘设备的设备文件命名：

				IDE: /dev/hd
				SCSI, SATA, SAS, USB: /dev/sd
					不同设备：a-z
						/dev/sda, /dev/sdb, ...
					同一设备上的不同分区：1,2, ...
						/dev/sda1, /dev/sda5

			机械式硬盘：
				track：磁道
				cylinder: 柱面
				secotr: 扇区
					512bytes

				如何分区：
					按柱面

				0磁道0扇区：512bytes
					MBR: Master Boot Record
						446bytes: boot loader
						64bytes：分区表
							16bytes: 标识一个分区
						2bytes: 55AA

						4个主分区；
							3主分区+1扩展(N个逻辑分区)
								逻辑分区

				问题：UEFI, GPT？

	分区管理工具：fdisk, parted, sfdisk
		fdisk：对于一块硬盘来讲，最多只能管理15分区；

		# fdisk -l [-u] [device...]

		# fdisk device
			子命令：管理功能
				p: print, 显示已有分区；
				n: new, 创建
				d: delete, 删除
				w: write, 写入磁盘并退出
				q: quit, 放弃更新并退出
				m: 查看帮助信息
				l: 列表所分区id
				t: 调整分区id

			注意：在已经分区并且已经挂载其中某个分区的磁盘设备上创建的新分区，内核可能在创建完成后无法直接识别‘

				查看：cat /proc/partitions
				通知内核强制重读磁盘分区表：
					CentOS5：partprobe [device]
					CentOS6/7：partx -a [device]
							   kpart -af [device]

				分区创建工具：parter,sfdisk

	创建文件系统：

		格式化：低级格式化(分区之前进行，划分磁道)、高级格式化（分区之后对分区进行，创建文件系统）

			元数据区，数据区
				元数据区：inode(index node)
					文件元数据：大小、权限、属主属组、时间戳、数据块指针

				符号链接文件：存储数据指针的空间当中存储的是真是文件的访问路径；
				设备文件：存储数据指针的空间当中存储的是设备号(major,minor)；

			bitmap index：位图索引

		VFS：Virtual File System
			Linux的文件系统：ext2(无日志功能),ext3,ext4,xfs,relserfs,btrfs
			光盘：iso9600
			网络文件系统：nfs,cifs
			集群文件系统：gfs2ocfs2
			内合级分布式文件系统：ceph
			windows的文件系统：vfat,vtfs
			伪文件系统：proc,sysfs,tmpfs,hugepagefs
			Unix的文件系统：UFS,FFS,JFS
			交换文件系统：swap
			用户空间的分布式文件系统：mogilefs,moosefs,glusterfs

		文件系统管理工具：
			创建文件系统工具
				mkfs
					mkfs.ext2,mkfs.ext3,mkfs.ext4,mkfs.xfs,mkfs.vfat,...
			检测及修复文件系统的工具
				fsck
					fsck.ext2,fsck.ext3,...
			查看其属性的工具
				dumpe2fs,tune2fs
			调整文件系统特性：
				tune2fs

	链接文件：访问同一个文件不同路径
		硬链接：指向同一个inode的多个文件路径；
			特性：
				(1)目录不支持硬链接；
				(2)硬链接不能跨文件系统；
				(3)创建硬链接会增加inode引用计数；

			创建：
				ln src link_file

		符号链接：指向文件路径的另一个文件路径；
			特性：
				(1)符号链接与源文件是两个各自独立的文件，各有自己的inode；对原文件创建符号链接不会增加引用计数；
				(2)支持对目录创建符号链接，可以跨文件系统；
				(3)删除符号链接文件不影响源文件；但删除原文件，符号链接指定的路径即不存在，此时会变成无效链接；

				注意：符号链接文件的大小是其指定的文件的路径字符串的字节数；

			创建：
				ln -s src link_file

				-v：verbose

回顾：磁盘、磁盘分区、文件系统

	CentOS 6,7：/dev/sd[a-z]#
	管理分区：fdisk,parted,sfdisk
	创建文件系统：
	Linux文件系统类型：ext2,ext3,ext4,xfs,reiserfs,iso9660,swap
	文件系统的组织结构中的术语：
		block groups,block,inode table,inode,inode bitmap,block bitmap,superblock

磁盘和文件系统管理


	文件系统管理工具：
		创建文件系统工具
			mkfs
				mkfs.ext2,mkfs.ext3,mkfs.ext4,mkfs.xfs,mkfs.vfat,...
		检测及修复文件系统的工具
			fsck
				fsck.ext2,fsck.ext3,...
		查看其属性的工具
			dumpe2fs,tune2fs
		调整文件系统特性：
			tune2fs

	内核及文件系统的组成部分：
		文件系统驱动：由内核提供
		文件系统管理工具：由用户空间的应用程序提供

	ext系列文件系统的管理工具：
		mkfs.ext2,mkfs.ext3,mkfs.ext4

		mkfs -t ext2 = mkfs.ext2

		ext系列文件系统专用管理工具：mke2fs
			mke2fs [options] device
				-t{[ext2|ext3|ext4]}：知名要创建的文件系统类型
					mkfs.ext4 = mkfs -t ext4 = mke2fs -t ext4

				-b{1024|2048|4096}：指明文件系统的块大小；
				-L LABEL：指明卷标；
				-j：创建有日志功能的文件系统ext3；
					mke2fs -j = mke2fs -t ext3 = mkfs -t ext3 = mkfs.ext3
				-i #：bytes-per-inode，指明inode与字节的比率；即每多少字节创建一个inode；
				-N #：直接指明要给此文件系统创建的inode的数量；
				-m #：指定预留的空间，百分比；

				-O [^]FEATURE：以指定的特性创建目标文件系统；

			e2label命令：卷标的查看与设定
				查看：e2label device
				设定：e2label device LABEL

			tune2fs命令：查看或修改ext系列文件系统的某些属性
				adjust tunable filesystem parameters on ext2/ext3/ext4 filesys‐tems；
				注意：块大小创建后不可修改；

				tune2fs [OPTIONS] device
					-l：查看超级块的内容；

					修改指定文件系统的属性：
						-j：ext2 --> ext3；
						-L LABEL：修改卷标；
						-m #：调整预留空间百分比；
						-O [^]FEATHER：开启或关闭某种特性；

						-o [^]mount_options：开启或关闭某种默认挂载选项；
							acl
							^acl

			dumpe2fs命令：显示ext系列文件系统的属性信息
				dumpe2fs [-h] device

			fsck命令：用于实现文件系统检测的工具

				因进程意外终止或系统崩溃等原因导致写入操作非正常终止时，可能会造成文件损坏；此时，应该检测并修复文件系统；建议，离线进行；

				ext系列文件系统的专用工具：
					e2fsck：check a Linux ext2/ext3/ext4 file system
						e2fsck [OPTIONS] device
							-y：对所有问题自动回答为yes；
							-f：即使文件系统处于clean状态，也要强制进行检测；

					fsck：check and repair a Linux filesystem
						-t fstype：指明文件系统类型；
							fsck -t ext4 = fsck.ext4
						-a：无须交互而自动修复所有错误；
						-r：交互式修复；

		CentOS 6如何使用xfs文件系统：
			# yum -y install xfsprogs

			事先：
				# cd /etc/yum.repos.d/
				# wget http://
				# mv CentOS-Base.repo CentOS-Base.repo.bak

			创建：mkfs.xfs
			检测：fsck.xfs

	blkid命令：
		blkid device
		blkid -L LABEL：根据LABEL定位设备
		blkid -U UUID：根据UUID定位设备

	swap文件系统：
		Linux上的交换分区必须使用独立的文件系统；
			且文件系统的System ID必须为82；

		创建swap设备：mkswap命令
			mkswap [OPTIONS] device
				-L LABEL：指明卷标
				-f：强制

	Windows无法识别Linux的文件系统；因此，存储设备需要两种系统之间交叉使用时，应该使用Windows和Linux同时支持的文件系统：fat32(vfat)；
		# mlfs.vfat device

	文件系统的使用：
		首先要“挂载”：mount命令和umount命令

		根文件系统之外的其他文件系统要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现；此关联操作极为“挂载”；此目录即为“挂载点”；
			挂载点：mount_point，用于作为另一个文件系统的访问入口；
				(1)事先存在；
				(2)应该使用未被或不会被其他进程使用到的目录；
				(3)挂在殿下原有的文件将会被隐藏；

		mount命令：
			mount [-nrw] [-t vfstype] [-o options] device dir

				命令选项：
					-r：readonly，只读挂载；
					-w：read and write，读写挂载；
					-n：默认情况下，设备挂载或卸载的操作会同步更新至/etc/mtab文件中；-n用于禁止此特性；

					-t vfstype：指明要挂在的设备上的文件系统的类型；多数情况下可省略，此时mount会通过blkid来判断要挂载的设备的文件系统类型；

					-L LABEL：挂载时以卷标的方式指明设备；
						mount -L LABEL dir

					-U UUID：挂载时以UUID的方式指明设备；
						mount -U UUID dir

				-o options：挂载选项
					sync/async：同步/异步操作；
					atime/noatime：文件或目录在被访问时是否更新其访问时间戳；
					diratime/nodiratime：目录在被访问时是否更新其访问时间戳；
					remount：重新挂载；
					acl：支持使用facl功能；
						# mount -o acl device dir
						# tune2fs -o acl device

					ro：只读
					rw：读写
					dev/nodev：此设备上是否允许创建设备文件；
					exec/noexec：是否允许运行此设备上的程序文件；
					auto/noauto：
					user/nouser：是否允许普通用户挂载此文件系统；
					suid/nosuid：是否允许程序文件上的suid和sgid特殊权限生效；

					defaults：Use default options: rw, suid, dev, exec, auto, nouser, and async.

			一个使用技巧：
				可以实现将目录绑定至另一个目录上，作为其临时访问入口；
					mount --bind 源目录 目标目录

			查看当前系统所有已挂载设备：
				# mount
				# cat /etc/mtab
				# cat /proc/mounts

			挂载光盘：
				mount -r /dev/cdrom mount_point

				光盘设备文件：/dev/cdrom,/dev/dvd

			挂载U盘：
				事先识别U盘设备文件；

			挂载本地的回环设备：
				# mount -o loop /PATH/TO/SOME_LOOP_FILE MOUNT_POINT

		umount命令：
			umount device|dir

			注意：正在被进程访问到的挂载点无法被卸载；
				查看被哪个或哪些进程所占用：
					# lsof MOUNT_POINT
					# fuser -v MOUNT_POINT

					终止所有正在访问某挂载点的进程：
					#fuser -km MOUNT_POINT

	交换分区启用和禁用：
		创建交换分区的命令：mkswap

		启用：swapom
			swapon [OPTION] [DEVICE]
				-a：定义在/etc/fstab文件中的所有swap设备

		禁用：swapoff
			swapoff DEVICE

	设定除根文件系统以外的其他文件系统能够开机时自动挂载：/etc/fstab文件
		每行定义一个要挂在的文件系统及其相关属性：
			6个字段：
				(1)要挂载的设备：
					设备文件；
					LABEL
					UUID
					伪文件系统：如sysfs,proc,tmpfs等
				(2)挂载点
					swap类型的设备的挂载点为swao；
				(3)文件系统类型；
				(4)挂载选项
					defaults：使用默认挂载选项；
					如果要同时指明多个挂载选项，彼此间以逗号分隔；
						defaults,acl,noatime,noexec
				(5)转储频率
					0：从不备份；
					1：每天备份；
					2：每隔一天备份；
				(6)自检次序
					0：不自检；
					1：首先自检，通常只能是根文件系统可用1；
					2：次级自检
					...

			mount -a：可自动挂载定义在此文件中的所有支持自动挂载的设备；

	两个命令：df和du
		df命令：
			df [OPTION]... [FILE]...
				-l：仅显示本地文件的相关信息；
				-h：human-readable
				-i：显示inode的使用状态而非blocks

		du命令：
			du [OPTION]... [FILE]...
				-s：sumary
				-h：human-readable

	练习：
		1、创建一个10G的分区。并格式化为ext4文件系统；
			(1)block大小为2048；预留空间为2%，卷标为MYDATA；
			(2)挂载至/mydata目录，要求挂载时禁止程序自动运行，且不更新文件的访问时间戳；
			(3)可开机自动挂载；

		2、创建一个大小为1G的swap分区，并启动之；

回顾：文件系统管理
	管理工具：mkfs,mke2fs,e2label,tune2fs,dumpe2fs,e2fsck,blkid
		mkfs.xfs,mkfs.vfat,fsck
		mkswap,swapon,swapoff
		mount,umount,fuser,lsof
		df,du

	fstab文件：
		设备	挂载点		文件系统类型 	挂载选项 	转储频率 	自检次序

	文件系统：
		目录：文件
			元数据：inode，inode table
			数据：date blocks
				下级文件或目录的文件名与其inode对应关系

				dentry

		文件名：上级目录；

		删除文件：将此文件指向的所有data block标记为未使用状态；将此文件的inode标记为未使用；
		复制和移动文件：
			复制：新建文件；
			移动文件：
				在同一文件系统：改变的仅是其路径；
				在不同文件系统：复制数据至目标文件，并删除原文件；

		符号链接：
			权限：lrwxrwxrwx
		硬链接：指向同一个inode；

bash脚本编程

	脚本文件格式：
		第一行，顶格#!/bin/bash 
		注释信息：#
		代码注释：
		缩进，适度添加空白行；

	语言：变成语法格式，库，算法和数据结构
	编程思想：
		问题空间 --> 解空间

	变量：
		局部变量
		本地变量
		环境变量

		位置参数变量
		特殊变量

	数据类型：字符型、数值型
		弱类型：字符型

	算术运算：
		+,-.*,/,%,**

		let VAR=expression
		VAR=$[expression]
		VAR=$((expression))
		VAR=$(expr argu1 argu2 argu3)

		注意：有些时候乘法符号需要转义；

		增强型赋值：
			变量做某种算术运算后回存至此变量中；
				let i=$i+#
				let i+=#

			+=,-=,*=,/=,%=

			自增：
				VAR=$[$VAR+1]
				let VAR+=1
				let VAR++

			自减：
				VAR=$[$VAR-1]
				let VAR-=1
				let VAR--

	练习：
		1、写一个脚本
			计算/etc/passwd文件中的第10个用户和第20个用户的id号之和；
				id1=$(head -10 /etc/passwd | tail -1 | cut -d: -f3)
				id2=$(head -20 /etc/passwd | tail -1 | cut -d: -f3)

		2、写一个脚本
			计算/etc/rc.d/init.d/functions和/etc/inittab文件的空白行数之和；

				grep "^[[:space:]]*$" /etc/rc.d/init.d/functions | wc -l

	条件测试：
		判断某需求是否满足，需要由测试机制来实现；

		如何编写测试表达式以实现所需的测试
			(1)执行命令，并利用命令状态返回值来判断；
				0：成功
				1-255：失败
			(2)测试表达式
				test EXPRESSION
				[ EXPRESSION ]
				[[ EXPRESSION ]]

				注意：EXPRESSION两端必须有空白字符，否则为语法错误；

		bash的测试类型：
			数值测试
			字符串测试
			文件测试

			数值测试：数值比较
				-eq：是否等于；[ $num1 -eq $num2 ]
				-ne：是否不等于；
				-gt：是否大于；
				-ge：是否大于等于；
				-lt：是否小于；
				-le：是否小于等于；

			字符串测试：
				==：是否等于；
				>：是否大于；
				<：是否小于；
				!=：是否不等于；
				=~：左侧字符串是否能够被右侧的PATTERN所匹配；

				-z "STRING"：判断指定的字符串是否为空；空则为真，不空则假；
				-n "STRING"：判断指定的字符串是否不空；不空则真，空则为假；

				注意：
					(1)字符串要加引用；
					(2)要使用[[]]；

			文件测试：
				存在性测试
					-a FILE
					-e FILE
						文件的存在性测试，存在则为真，否则则为假；
				存在性及类型测试
					-b FILE：是否存在并且为 块设备 文件；
					-c FILE：是否存在并且为 字符设备 文件；
					-d FILE：是否存在并且为 目录文件；
					-f FILE：是否存在并且为 普通文件；
					-h FILE或 -L FILE：是否存在并且为 符号链接文件；
					-p FILE：是否存在且为 管道命名文件；
					-S FILE：是否存在且为 套接字文件；
				文件权限测试：
					-r FILE：是否存在并且 对当前用户可读；
					-w FILE：是否存在并且 对当前用户可写；
					-x FILE：是否存在并且 对当前用户可执行；
				特殊权限测试：
					-u FILE：是否存在并且 拥有suid权限；
					-g FILE：是否存在并且 拥有sgid权限；
					-k FILE：是否存在并且 拥有STICKY权限；
				文件是否有内容：
					-s FILE：是否有内容；
				时间戳：
					-N FILE：文件自从上一次读操作后是否被修改过；
				从属关系测试：
					-O FILE：当前用户是否为文件的属主；
					-G FILE：当前用户是否属于文件的属组；
				双目测试：
					FILE1 -ef FILE2：FILE1与FILE2是否为指向同一个文件系统的相同inode的硬链接；
					FILE1 -nt FILE：FILE1是否新于FILE2；
					FILE2 -ot FILE：FILE1是否旧于FILE2；

			组合测试条件：
				逻辑运算：
					第一种方式：
						COMMAND1 && COMMAND2
						COMMAND1 || COMMAND2
						!COMMAND 

						[-O FILE ] && [-r FILE]

					第二种方式：
						EXPRESSION1 -a EXPRESSION2
						EXPRESSION1 -o EXPRESSION2
						!EXPRESSION

						[-O FILE -a -x FILE]

				练习：将当前主机名称保存至hostName变量中；
					主机名如果为空，或者为localhost.localdomain，则将其设置为www.magedu.com；

					hostName=$(hostname)

					[ -z "$hostName" -o "hostName"=="localhost.localdomain" -o "$hostName"=="localhost" ] && hostname www.magedu.com

		脚本的状态返回值：
			默认是脚本中执行的最后一条命令的状态返回值；自定义状态退出状态码；
				exit[n]：n为自己指定的状态码；
					注意：shell进程遇到exit是，即会终止，因此，整个脚本执行即为结束；

	向脚本传递参数：
		位置参数变量

		myscript.sh argu1 argu2
			引用方式：
				$1,$2,...,${10},${11},...

			轮替：
				shift [n]：位置参数轮替；

		练习：写一个脚本，通过命令行传递两个文本文件路径给脚本，计算其空白行数之和；

			#!/bin/bash
			#
			file1_lines=$(grep "^$" $1 | wc -l)
			file2_lines=$(grep "^$" $2 | wc -l)

			echo "$Total blank lines: $[file1_lines+$file2_lines]"

	特殊变量：
		$0：脚本文件路径本身； 
		$#：脚本参数的个数；
		$*：所有参数；
		$@：所有参数

	过程式编程语言的代码执行顺序：
		顺序执行：逐条运行；
		选择执行：
			代码有一个分支：条件满足时才会执行；
			两个或以上的分支：只会执行其中一个满足条件的分支；
		循环执行：
			代码片段（循环体）要执行0、1或多个来回；

		选择执行：
			单分支的if语句：
				if 测试条件
				then
					代码分支
				fi

			双分支的if语句：
				if 测试条件;then
					条件为真时执行的分支
				else
					条件为假时执行的分支
				fi

		示例：通过参数传递一个用户名给脚本，此用户不存在时，则添加之；
			#!/bin/bash
			#
			if ! grep "^$1\>" /etc/passwd &> /dev/null; then
				useradd $1
				echo $1 | passwd --stdin $1 &> /dev/null
				echo "Add user $1 finished."
			fi

			#!/bin/bash
			#
			if [ $# -lt 1 ]; then
			    echo "At least one username."
			    exit 2
			fi

			if ! grep "^$1\>" /etc/passwd &> /dev/null; then
			    useradd $1
			    echo $1 | passwd --stdin $1 &> /dev/null
			    echo "Add user $1 finished."
			fi

			#!/bin/bash
			#
			if [ $# -lt 1 ]; then
			    echo "At least one username."
			    exit 2
			fi

			if grep "^$1\>" /etc/passwd &> /dev/null; then
			    echo "User $1 exists."
			else
			    useradd $1
			    echo $1 | passwd --stdin $1 &> /dev/null
			    echo "Add user $1 finished."
			fi

		练习1：通过命令行参数给定两个数字，输出其中较大的数值；
			#!/bin/bash
			#
			if [ $# -lt 2]; then
				echo "Two integers."
				exit 2
			fi

			if [ $1 -ge $2 ]; then
				echo "Max number: $1."
			else
				echo "Max number: $2."
			fi


			#!/bin/bash
			#

			if [ $# -lt 2 ]; then
			    echo "Two integers."
			    exit 2
			fi

			declare -i max=$1

			if [ $1 -lt $2 ]; then
			    max=$2
			fi

			echo "Max number: $max."

		练习2：通过命令行参数给定一个用户名，判断其ID号是偶数还是奇数；
		练习3：通过命令行参数给定两个文件名，如果某文件不存在，则结束脚本执行；都存在时返回每个文件的行数，并说明其中行数较多的文件；

RAID：
	Redundant Arrays of Inexpensive Disks
						Independent

	Berkeley：A case for Redundent Arrays of Inexpensive Disk RAID

		提高IO能力：
			磁盘并行读写；
		提高耐用性：
			磁盘冗余来实现；

		级别：多块磁盘组织在一起的工作方式有所不同；
		RAID实现的方式：
			外接式磁盘阵列：通过扩展卡提供适配能力
			内接式RAID：主板集成RAID控制器
			Software RAID：

	级别：level
		RAID-O：0，条带卷，strip;
		RAID-1：1，镜像卷，mirror;
		RAID-2
		..
		RAID-5
		RAID-6
		RAID10
		RAID01

		RAID-0：
			读、写性能提升；
			可用空间：N*min(S1,S2,...)
			无容错能力
			最少磁盘数：2，2+

		RAID-1：
			读性能提升、写性能略有下降；
			可用空间：1*min(S1,S2,...)
			有冗余能力
			最少磁盘数：2，2+

		RAID-4：
			1101，0110，1011
				  0110

		RAID-5：
			读、写性能提升
			可用空间：(N-1)*min(S1,S2,...)
			有容错能力：1块磁盘
			最少磁盘数：3，3+

		RAID-6：
			读、写性能提升
			可用空间：(N-2)*min(S1,S2,...)
			有容错能力：2块磁盘
			最少磁盘数：4，4+

		混合类型
			RAID-10：
				读、写性能提升
				可用空间：N*min(s1,s2,...)/2
				有容错能力：每组镜像最多只能坏一块；
				最少磁盘数：4，4+
			RAID-01：

			RAID-50、RAID7

			JBOD：Just a Bunch Of Disks
				功能：将多块磁盘的空间合并成一个大的连续空间使用；
				可用空间：sum(S1,S2,...)

		常用级别：RAID-0,RAID-1,RAID-5,RAID-10,RAID-50,JBOD

		实现方式：
			硬件实现方式
			软件实现方式

			CentOS 6上的软件RAID的实现：
				结合内核中的md(multi devices)

				mdadm：模式化的工具
					命令的语法格式：mdadm [mode] <raiddevice? [OPTIONS] <component-devices>
						支持的RAID级别：LINEAR,RAID0,RAID1,RAID4,RAID5,RAID6,RAID10;

					模式：
						创建：-C
						装配：-A
						监控：-F
						管理：-f,-r,-a

					<raiddevice>:/dev/md#
					<component-devices>：任意块设备

					-C：创建模式
						-n #：使用#个块设备来创建此RAID；
						-l #：指明要创建的RAID的级别；
						-a {yes|no}：自动创建目标RAID设备的设备文件；
						-c CHUNK_SIZE：指明块大小；
						-x #：指明空闲盘的个数；

						例如：创建一个10G可用空间的RAID5；

					-D：显示raid的详细信息：
						mdadm -D /dev/md#

					管理模式：
						-f：标记指定磁盘为损坏；
						-a：添加磁盘
						-r：移除磁盘

					观察md的状态：
						cat /proc/mdstat

					停止md设备：
						mdadm -S /dev/md#

				watch命令：
					-n #：刷新间隔，单位是秒；

					watch -n# 'COMMAND'

		练习1：创建一个可用空间为10G的RAID1设备，要求其chunk大小为128k，文件系统为ext4,有一个空闲盘，开机可自动挂载至/backup目录；
		练习2：创建一个可用空间为10给的RAID10设备，要求其chunk大小为256k，文件系统为ext4,开机可自动挂载至/mydata目录；

	博客作业：raid各级别特性；

LVM2：
	
	LVM：Logical Volume Manager, Version：2

	dm：device mapper，将一个或多个底层块设备组织成一个逻辑设备的模块；
		/dev/dm-#

	/dev/mapper/VG_NAME-LV_NAME
		/dev/mapper/vol0-root 
	/dev/VG_NAME/LV_NAME
		/dev/vol0/root

	pv管理工具：
		pvs：简要pv信息显示
		pvdisplay：显示pv的详细信息

		pvcreate /dev/DEVICE：创建pv

	vg管理工具：
		vgs
		vgdisplay

		vgcreate
		vgextend
		vgreduce
			先做pvmove

		vgremove

	lv管理工具
		lvs
		lvdisplay

		lvcreate -L #[mMgGtT] -n NAME VolumeGroup

		lvremove /dev/VG_NAME/LV_NAME

	扩展逻辑卷：
		# lvextend -L [+]#[mMgGtT] /dve/VG_NAME/LV_NAME
		# resize2fs /dev/VF_NAME/LV_NAME

	缩减逻辑卷：
		# umount /dev/VG_NAME/LV_NAME
		# e2fsck -f /dev/VG_NAME/LV_NAME
		# resize2fs /dev/VG_NAME/LV_NAME #[mMgGtT]
		# lvreduce -L [-]#[mMgGtT] /dve/VG_NAME/LV_NAME
		# mount

	快照：snapshot
		lvcreat -L #[mMgGtT] -p r -s -n snapshort_lv_name origibal_lv_name

文件系统挂载使用：
	挂载光盘设备：
		光盘设备文件：
			IDE：/dev/hdc
			SATA：/dev/sr0

			符号链接文件：
				/dev/cdrom
				/dev/cdrw
				/dev/dvd
				/dev/dvdrw

		mount -r /dev/cdrom /media/cdrom
		umount /dev/cdrom

	dd命令：convert and copy a file
		用法：
			dd if=/PATH/FROM/SRC of=/PATH/TO/DEST
				bs=#：block size，复制单元大小；
				count=#：复制多少个bs；

			磁盘拷贝：
				dd if=/dev/sda of=/dev/sdb

			备份MBR
				dd if=/dev/sda of=/tmp/mbr.bak bs=512 count =1

			破坏MBR中的bootloader：
				dd if=/dev/zero of=/dev/sda bs=256 count=1

		两个特殊设备：
			/dev/null：数据黑洞；
			/dev/zero：吐零机；

	博客作业：lvm基本应用，扩展及缩减实现；

回顾：lvm2,dd
	lvm：边界动态扩展或收缩；快照；
		pv --> vg --> lv
			PE：
			LE:

	dd：复制

btrfs文件系统：
	技术预览版

	Btrfs(B-tree,  Butter FS, Better FS), GPL, Oracel, 2007, CoW; 
	ext3/ext4, xfs

	核心特性：
		多物理卷支持：btrfs可由多个底层物理卷组成：支持RAID，以联机“添加”、“移除”、“修改”；
		写时复制更新机制(CoW)：复制、更新及替换指针，而非“就地”更新；
		数据及元数据校验码；
		子卷：sub_volume
		快照：支持快照的快照
		透明压缩：

	文件系统创建：
		mkfs.btrfs
			-L 'LABEL'
			-d <type>: raid0, raid1, raid5, raid6, raid10, single
			-m <profile>: raid0, raid1, raid5, raid6, raid10, single, dup
			-O <feature>
				-O list-all：列出支持的所有feature；

		属性查看：
			btrfs filesystem show

		挂载文件系统：
			mount -t btrfs /dev/sdb MOUNT_POINT

		透明压缩机制：
			mount -o compress={lzo|zlib} DEVICE MOUNT_POINT

回顾：
	RAID：Level
	LVM：Volume
	btrfs：了解；

压缩和解压缩工具和bash脚本编程；

	压缩比
		目的：时间 换 空间
			CPU的时 --> 磁盘空间

	compress/uncompress,.Z
	gzip/gunzip, .gz
	bzip2/bunzip2, .bz2
	xz/unxz, .xz
	lzma/unlzma, lzma
	zip/unzip
	tar,cpio

	1、gzip/gunzip/cat
		gzip, gunzip, zcat - compress or expand files

		gzip [OPTION]... FILE...
			-d：解压缩，相当于gunzip；
			-#：指定压缩比，默认是6；数字越大压缩比越大(1-9)；
			-c：将压缩结果输出至标准输出；
				gzip -c FILE > /PATH/TO/SOMEFILE.gz

	2、bzip2/bunzip2,bzcap

		bzip2 [OPTION]... FILE...
			-d：解压缩
			-#：制定压缩比；默认是6；数字越大压缩比越大(1-9)；
			-k：keep，保留原文件；

	3、xz/unxz/xzcat
	   	lzma/unlzma/lzcat

	  	xz [OPTION]... FILE...
	   		-d：解压缩
	   		-#：指定压缩比，默认是6；数字越大压缩比越大(1-9)；
	   		-k：保留原文件；

	归档：tar,cpio

		tar命令：
			tar [OPTION]... FILE...

			(1)创建归档
				-c -f /PATH/TO/SOMEFILE.tar FILE...
				-cf /PATH/TO/SOMEFILE.tar FILE...

			(2)展开归档
				-xf /PATH/TO/SOMEFILE.tar FILE...
				-xf /PATH/TO/SOMEFILE.tar FILE... -C /PATH/TO/SOMEDIR

			(3)查看归档文件的文件列表
				-tf /PATH/TO/SOMEFILE.tar

		归档完成后通常需要压缩，结合此前的压缩工具，就能实现压缩多个文件了；
			(4)归档并压缩
				-z：gizp2
					-zcf /PATH/TO/SOMEFILE.tar.gz FILE...
					解压缩并展开归档：-zxf /PATH/TO/SOMEFILE.tar.gz

				-j：bzip2
					-jcf
					-jxf

				-J: xz
					-Jcf
					-Jxf

	zip：
		zip/unzip
			后缀名：.zip

	练习：下载redis-3.0.2.tar.gz, 展开至/tmp目录；而后重新创建压缩为xz格式

bash脚本编程之用户交互：
	
	脚本参数

	用户交互：通过键盘输入数据，从而完成变量赋值操作；
		read [option]... [name]...
			-p prompt
			-t timeout

			#!/bin/bash
			#
			read -p "Enter a username: " name
			[ -z "$name" ] && echo "a username is needed." && exit 2

			read -p "Enter a password for $name, [password]: " password
			[ -z "$password" ] && echo password="password"

			if id $name &> /dev/null; then
			    echo "$name exists."
			else
			    useradd $name
			    echo "$password" | passwd --stdin $name &> /dev/null
			fi

	bash -n /path/to/some_script
		检测脚本中的语法错误

	bash -x /path/to/some_script
		调试执行

Linux任务计划、周期性任务执行

	未来的某时间点执行一次某任务：at, batch
	周期性运行某任务：crontab
		执行结果：会通过邮件发给用户

		~]# netstat -tnl
		~]# ss -tnl

	本地电子邮件服务：
		smtp: simple mail transmission protocol
		pop3: Post Office Procotol
		imap4: Internet Mail Access Procotol

		mail命令：
			mailx - send and receive Internet mail

				MUA: Mail User Agent, 用户收发邮件的工具程序；

				mailx [-s 'SUBJECT'] username[@hostname]
					邮件正文的生成：
						(1)交互式输入；. 单独成行可以表示正文结束；Ctrl+d提交亦可；
						(2)通过输入重定向；
						(3)通过管道；

	at命令：
		at [OPTION]... TIME

			TIME: 
				HH:MM [YYYY-mm-dd]
				noon, midnight, teatime
				tomorrow
				now+#
					UNIT: minutes,hours,days,OR weeks

			at的作业有队列，用单个字母表示，默认都使用a队列；

			常用选项：
				-l: 查看作业队列，相当于atq
				-f /PATH/FROM/SOMEFILE: 从指定文件中读取作业任务，而不用再交互式输入；
				-d：删除指定的作业，相当于atrm；
				-c: 查看制定作业的具体内容；
				-q QUEUE: 指明队列；

			注意：作业执行结果是以邮件发送给提交作业的用户；

	batch命令：
		batch会让系统自行选择在系统资源较空闲的时间去执行指定的任务；

	周期性任务计划：cron
		服务程序：
			cronie: 主程序包，提供了crond守护进程和相关辅助工具；

		确保crond守护进程(deamon)处于运行状态：
			CentOS 7:
				systemctl status crond.service
					Active: active (running)...

			CentOS 6:
				service crond status
					... is running.

		向crond提交作业的方式不同于at，它需要使用专用的配置文件，此文件有固定格式，不建议使用文本编辑器直接编辑此文件；要使用crontab命令；
			cron任务分为两类：
				系统cron任务：主要用于实现系统自身的维护；
					手动编辑：/etc/crontab文件
				用户cron任务：
					命令：crontab命令

			系统cron的配置格式：
				SHELL=/bin/bash
				PATH=/sbin:/bin:/usr/sbin:/usr/bin
				MAILTO=root

				# For details see man 4 crontabs

				# Example of job definition:
				# .---------------- minute (0 - 59)
				# |  .------------- hour (0 - 23)
				# |  |  .---------- day of month (1 - 31)
				# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
				# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
				# |  |  |  |  |
				# *  *  *  *  * user-name  command to be executed

				注意：
					(1)每一行定义一个周期性任务，共7个字段
						* * * * *：定义周期性时间
						user-name：运行任务的用户身份
						command to be executed：任务
					(2)此处的环境变量不同于用户登陆后获得的环境变量，因此，建议命令使用绝对路径，或者自定义PATH环境变量；
					(3)执行结果邮件发送给MAILTO指定的用户

			用户cron的配置格式：/var/spool/cron/USERNAME
				SHELL=/bin/bash
				PATH=/sbin:/bin:/usr/sbin:/usr/bin
				MAILTO=root

				# For details see man 4 crontabs

				# Example of job definition:
				# .---------------- minute (0 - 59)
				# |  .------------- hour (0 - 23)
				# |  |  .---------- day of month (1 - 31)
				# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
				# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
				# |  |  |  |  |
				# *  *  *  *  * command to be executed

				注意：
					(1)每行定义一个cron任务，共6字段；
					(2)此处的环境变量不同于用户登陆后获得的环境变量，因此，建议命令使用绝对路径，或者自定义PATH环境变量；
					(3)邮件发送给当前用户；

			时间表示法：
				(1)特定值：
					给定时间有效取值范围内的值；
						注意：day of week和day of month一般不同时使用；
				(2)*
					给定时间点上有效取值范围内的所有值；表“每..”
				(3)离散取值：,
					在时间点上使用逗号分割的多个值；
						#,#,#
				(4)连续取值：-
					在时间点上使用-连接开头和结束
						#-#
				(5)在指定时间点上，定义步长: 
					/#：#即步长；

					注意：
						(1)指定的时间点不能被步长整除时，其意义将不服存在；
						(2)最小时间单位为“分钟”，想完成“秒”级任务，得需要额外借助于其他机制；
							定义成每分钟任务；而后利用脚本实现在每分钟之内，循环执行多次；

			示例：
				(1)3 * * * *: 每小时执行一次；每小时的第3分钟；
				(2)3 4 * * 5：每周执行一次；每周5的4点3分；
				(3)5 6 7 * *：每月执行一次；每月的7号的6点5分；
				(4)7 8 9 10 *：每年执行一次，每年的10月9号8点7分；
				(5)9 8 * * 3,7：每周三和周日；
				(6)0 8,20 * * 3,7；
				(7)0 9-18 * * 1-5：
				(8)*/5 * * * *：每5分钟执行一次某任务；
				(9)*/7

			crontab命令：
				crontab [-u user] [-l | -r | -e] [-i] 
					-e：编辑任务；
					-l：列出所有任务；
					-r：移除所有任务；即删除/var/spool/cron/USERNAME文件；
					-i：在使用-r选项移除所有任务时提示用户确认；
					-u user：root用户可为指定用户管理cron任务；

			注意：运行结果以邮件通知给当前用户；如果拒绝接收邮件：
				(1)COMMAND > /dev/null
				(2)COMMAND &> /dev/null

			注意：定义COMMAND时，若果命令需要用到%，需要对其转义；但放置于单引号中的%不用转义亦可；

			思考：某任务在指定的时间因关机未能执行，下次开机会不会自动执行？
				不会！
				如果某时间点因故未能按时执行，下次开机后无论是否到了相应时间点都要执行一次，可使用anacron实现；

			课外作业：anacron及其应用；

	练习：
		1、每12小时备份一次/etc目录至/backups目录中，保存文件 名称格式为 “etc-yyyy-mm-dd-hh.tar.gz”
		2、每周2、4、7备份/var/log/secure文件至/logs目录中，文件名格式为“secure-yyyymmdd”
		3、每两小时去除当前系统/proc/meminfo文件中以S或M开头的行信息追加至/tmp/meminfo.txt文件中；

		12,24 * * * tar zcf /backups/etc-yyyy-mm-dd-hh.tar.gz /etc
     	0 0 * * 2,4,7 tar cf /logs/secure-yyyymmdd.tar /var/log/secure

Linux程序包管理

	概述：
		API：Application Program Interface
		ABI：Application Binary Interface
			Unix-like,
				ELF
			Windows
				exe, msi

			库级别的虚拟化：
				Linux: WinE
				Windows: Cywin

		系统级开发：
			C/C++：httpd, vsftpd, nginx
			go
		应用级开发：
			java/Python/perl/ruby/php：
				java: hadoop, hbase, (jvm)
				Python：openstack, (pvm)
				perl:(perl)
				ruby:(ruby)
				php:(php)

		C/C++程序格式：
			源代码：文本格式的程序代码；
				编译开发环境：编译器、头文件、开发库
			二级制格式：文本格式的程序代码 --> 编译器 --> 二进制格式(二进制程序、库文件、配置文件、帮助文件)

		java/Python程序格式：
			源代码：编译成能够在其虚拟机(jvm/pvm)运行的格式；
				开发环境：编译器、开发库
			二进制

		项目构建工具：
			c/c++: make
			java: maven

	程序包管理器：
		源代码 --> 目标二进制格式(二进制程序、库文件、配置文件、帮助文件) --> 组织成为一个或有限几个“包”文件；
			安装、升级、卸载、查询、校验

		程序包管理器：
			debian：dpt, dpkg, ".deb"
			redhat：redhat package manager, rpm, ".rpm"；rpm is package manager；
			S.u.S.E：rpm, ".rpm",

			Gentoo：ports
			ArchLinux：

		源代码：name-VERSION.tar.gz 
			VERSION：major.minor.release
		rpm包命令格式：
			name-VERSION-release.arch.rpm 
				VERSION：major.minor.release
				release.arch：rpm包的发行号
					release.os：2.el7.i386.rpm
					archetecture：i386, x64(amd64), ppc, noarch

				redis-3.0.2.tar.gz --> redis-3.0.2-1.centos7.x64.rpm 

			拆包：主包和支包
				主包：name-VERSION-release.arch.rpm
				支包：name-function-VERSION-release.arch.rpm
					function:devel, utils, libs, ...

		依赖关系：
			X, Y, Z

				X --> Y,Z
					Y --> A, B, C
					C --> Y

			前端工具：自动解决依赖关系；
				yum：rhel系列系统上rpm包管理器的前端工具；
				apt-get(apt-catch)：deb包管理器的前端工具；
				zypper：suse的rpm管理器前端工具；
				dnf：Fedora 22+系统上rpm包管理器的前端工具；

		程序包管理器：
			功能：将编译好的应用程序的各组成文件打包成一个或几个程序包文件，从而更方便地实现程序包的安装、升级、卸载和查询等管理操作；

			1、程序包的组成清单(每个程序包都单独实现)；
				文件清单
				安装或卸载时运行的脚本
			2、数据库（公共）
				程序包的名称和版本；
				依赖关系；
				功能说明；
				安装生成的各文件的文件路径及校验码信息；
				等等等

				/var/lib/rpm/

	获取程序包的途径：
		(1)系统发行版的光盘或官方的文件服务器（或镜像站点）；
			http://mirrors.aliyun.com,
			http://mirrors.sohu.com,
			http://mirrors.163.com
		(2)项目的官方站点
		(3)第三方组织：
			(a)EPEL
			(b)搜索引擎
				http://pkgs.org
				http://rpmfind.net
				http://rpm.pbone.net

		(4)自己动手，丰衣足食

		建议：检查其合法性
			来源合法性；
			程序包的完整性；

	CentOS系统上rpm命令管理程序包：
		安装、升级、卸载、查询和校验、数据库维护

		rpm命令：rpm [OPTIONS] [PACKAGE_FILE]
			安装：-i, --install
			升级：-U, --update, -F, --freshen
			卸载：-e, --erease
			查询：-q, --query
			校验：-V, --verify
			数据库维护：--builddb, initdb

		安装：
			rpm {-i|--install} [install-options] PACKAGE_FILE ...

				rpm -ivh PACKAGE_FILE

				GENERAL OPTIONS：
					-v：verbose，详细信息
					-vv：更详细的输出

				[install-options]：
					-h：hash marks输出进度条；每个#表示2%的进度；
					--test：测试安装，检查并报告依赖关系及冲突消息等；
					--nodeps：忽略依赖关系；不建议；
					-replacepkgs：重新安装；

					注意：rpm可以自带脚本；
						四类：--noscripts
							preinstall：安装过程开始之前运行的脚本，%pre, --nopre
							postinstall：安装过程完成之后运行的脚本，%post, --nopost
							preuninstall：卸载过程真正开始执行之前运行的脚本，%preun, --nopreun
							postuninstall：卸载过程完成之后运行的脚本，%postyn, --nopostun

					--nosignature：不检查包签名信息，不检查来源合法性；
					--nodegist：不检查包完整信息；

		升级：
			rpm {-U|--upgrade} [install-options] PACKAGE_FILE ...
			rpm {-F|--freshen} [install-options] PACKAGE_FILE ...
				-U：升级或安装；
				-F：升级

				rpm -Uvh PACKAGE_FILE ...
				rpm -Fvh PACKAGE_FILE ...

					--oldpackage：降级；
					--force：强制升级；

				注意：(1)不要对内核做升级操作；Linux支持多内核版本并存，因此，直接安装新版本内核；
					  (2)如果某源程序包的配置文件安装后曾被修改过，升级时，新版本的程序提供的同一个配置文件不会覆盖原有版本的配置文件，而是把新版本的配置文件重命名(FILENAME.rpmnew)后提供；

		卸载：
			rpm {-e|--erase} [--allmatches]  [--justdb]  [--nodeps]  [--noscripts] [--test] PACKAGE_NAME ...

				--allmatcher：卸载所有匹配指定名称的程序包的各版本；
				--nodeps：忽略依赖关系；
				--test：测试卸载，dry run模式

		查询：
			rpm {-q|--query} [select-options] [query-options]


			[select-options]
				PACKAGE_NAME：查询指定的程序包是否已经安装，及其版本；
				-a, --all：查询所有已经安装过的包；
				-f FILE：查询指定的文件由哪个程序包安装生成；

				-p, --package PACKAGE_FILE：用于实现对未安装的程序包执行查询操作；

				--whatprovides CAPABILITY：查询指定的CAPABILITY由哪个程序包提供；
				--whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖；

			[query-options]
				--changelog：查询rpm包的changelog；
				-l, --list：程序安装生成的所有文件列表；
				-i, --info：程序包相关的信息，版本号、大小、所属的包组，等；
				-c, --configfiles：查询指定的程序提供的配置文件；
				-d, --docfiles：查询指定的程序包提供的文档；
				--provides：列出指定的程序包提供的所有的CAPABILITY
				-R, --requires：查询指定的程序包的依赖关系；
				--scripts：查看程序包自带的脚本片段；

			用法：
				-qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE
				-qpi PACKAGE_FILE, -qpl PACKAGE_FILE, -qpc PACKAGEFILE, ...

		校验：
			rpm {-V|--verify} [select-options] [verify-options]

			S file Size differs
	        M Mode differs (includes permissions and file type)
	        5 digest (formerly MD5 sum) differs
	        D Device major/minor number mismatch
	        L readLink(2) path mismatch
	        U User ownership differs
	        G Group ownership differs
	        T mTime differs
	        P caPabilities differ

	包来源合法性验证和完整性验证：
		来源合法性验证：
		完整性验证：

		获取并导入信任的包制作者的的密钥：
			对于CentOS发行版来说；rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

		验证：
			(1)安装此组织签名的程序时，会自动执行验证；
			(2)手动验证：rpm -K PACKAGE_FILE

	数据库重建：
		rpm管理器数据库路径：/var/lib/rpm/
			查询操作：通过此处的数据库进行；

		获取帮助：
			CentOS6：man rpm
			CentOS7：man rpmdb

			rpm {--initdb|--rebuilddb}
				--initdb：初始化数据库，当前无任何数据库可初始化创建一个新的；当前有时不执行任何操作；
				-rebuilddb：重新构建，通过读取当前系统上所有已经安装过的程序包进行重新创建；

	博客作业：rpm包管理功能全解；

回顾：Linux程序包管理的实现、rpm包管理器

	rpm命令实现程序管理：
		安装：-ivh, --nodeps, --replacepkgs
		卸载：-e, --nodeps
		升级：-Uvh, -Fvh, --nodeps, --oldpackage
		查询：-q, -qa, -qf, -qi, -qd, -qc, -q --scripts, -q --changlog, -q --provides, -q --requires
		校验：-V

		导入GPG密钥：--import, -K, --nodigst, --nosignature
		数据库重建：--initdb, --rebuilddb

Linux程序包管理(2)

	CentOS：yum, dnf

	URL：ftp://172.16.0.1/pub/

	YUM：yellow dog, Yellow Update Modifier

	yum reposistory: yum repo
		存储了众多rpm包，以及包的相关的元数据文件(放置于特定目录下：repodata)；

		文件服务器：
			ftp://
			http://
			nfs://
			file://

	yum客户端
		配置文件：
			/etc/yum.conf：为所有仓库提供公共配置
			/etc/yum.repos.d/*.repo：为仓库的指向提供配置

		仓库指向的定义：
		[repositoryID]
		name=Some name for this repository
		baseurl=url://path/to/repository/
		enabled={1|0}
		gpgcheck]{1|0}
		gpgkey=URL
		enablegroups={1|0}
		failovermethod={roundrobin|priority}
			默认为：roundwobin：意为随机
		cost=#
			#默认为1000

















