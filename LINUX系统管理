Linux系统入门

Linux系统管理
	磁盘管理、文件系统管理
	RAID基础原理、LVM2
	网络管理：TCP/IP协议、Linux网络属性配置
	程序包管理：rpm, yum
	进程管理：htop, glance, tsar等
	sed和awk
	Linux系统开机流程
	内核管理基础知识：编译内核、模块
	Linux系统裁剪
		kernel+busybox
	课外作业：LFS

回顾：find、特殊权限、if语句

Linux磁盘管理

	I/O Ports: I/O设备地址；

	一切皆文件：
		open(), read(), write(), close()

		块设备：block，存取单位“块”，磁盘
		字符设备：char，存取单位“字符”，键盘

		设备文件：关联至一个设备驱动程序，进而能够跟与之对应硬件设备进行通信；

			设备号码：
				主设备号：major number, 标识设备类型
				次设备号：minor number, 标识同一类型下的不同设备

			硬盘接口类型：
				并行：
					IDE：133MB/s
					SCSI：640MB/s
				串口：
					SATA：6Gbps
					SAS：6Gbps
					USB：480MB/s

					rpm: rotations per minute


			/dev/DEV_FILE
				磁盘设备的设备文件命名：

				IDE: /dev/hd
				SCSI, SATA, SAS, USB: /dev/sd
					不同设备：a-z
						/dev/sda, /dev/sdb, ...
					同一设备上的不同分区：1,2, ...
						/dev/sda1, /dev/sda5

			机械式硬盘：
				track：磁道
				cylinder: 柱面
				secotr: 扇区
					512bytes

				如何分区：
					按柱面

				0磁道0扇区：512bytes
					MBR: Master Boot Record
						446bytes: boot loader
						64bytes：分区表
							16bytes: 标识一个分区
						2bytes: 55AA

						4个主分区；
							3主分区+1扩展(N个逻辑分区)
								逻辑分区

				问题：UEFI, GPT？

	分区管理工具：fdisk, parted, sfdisk
		fdisk：对于一块硬盘来讲，最多只能管理15分区；

		# fdisk -l [-u] [device...]

		# fdisk device
			子命令：管理功能
				p: print, 显示已有分区；
				n: new, 创建
				d: delete, 删除
				w: write, 写入磁盘并退出
				q: quit, 放弃更新并退出
				m: 查看帮助信息
				l: 列表所分区id
				t: 调整分区id

			注意：在已经分区并且已经挂载其中某个分区的磁盘设备上创建的新分区，内核可能在创建完成后无法直接识别‘

				查看：cat /proc/partitions
				通知内核强制重读磁盘分区表：
					CentOS5：partprobe [device]
					CentOS6/7：partx -a [device]
							   kpart -af [device]

				分区创建工具：parter,sfdisk

	创建文件系统：

		格式化：低级格式化(分区之前进行，划分磁道)、高级格式化（分区之后对分区进行，创建文件系统）

			元数据区，数据区
				元数据区：inode(index node)
					文件元数据：大小、权限、属主属组、时间戳、数据块指针

				符号链接文件：存储数据指针的空间当中存储的是真是文件的访问路径；
				设备文件：存储数据指针的空间当中存储的是设备号(major,minor)；

			bitmap index：位图索引

		VFS：Virtual File System
			Linux的文件系统：ext2(无日志功能),ext3,ext4,xfs,relserfs,btrfs
			光盘：iso9660
			网络文件系统：nfs,cifs
			集群文件系统：gfs2ocfs2
			内合级分布式文件系统：ceph
			windows的文件系统：vfat,vtfs
			伪文件系统：proc,sysfs,tmpfs,hugepagefs
			Unix的文件系统：UFS,FFS,JFS
			交换文件系统：swap
			用户空间的分布式文件系统：mogilefs,moosefs,glusterfs

		文件系统管理工具：
			创建文件系统工具
				mkfs
					mkfs.ext2,mkfs.ext3,mkfs.ext4,mkfs.xfs,mkfs.vfat,...
			检测及修复文件系统的工具
				fsck
					fsck.ext2,fsck.ext3,...
			查看其属性的工具
				dumpe2fs,tune2fs
			调整文件系统特性：
				tune2fs

	链接文件：访问同一个文件不同路径
		硬链接：指向同一个inode的多个文件路径；
			特性：
				(1)目录不支持硬链接；
				(2)硬链接不能跨文件系统；
				(3)创建硬链接会增加inode引用计数；

			创建：
				ln src link_file

		符号链接：指向文件路径的另一个文件路径；
			特性：
				(1)符号链接与源文件是两个各自独立的文件，各有自己的inode；对原文件创建符号链接不会增加引用计数；
				(2)支持对目录创建符号链接，可以跨文件系统；
				(3)删除符号链接文件不影响源文件；但删除原文件，符号链接指定的路径即不存在，此时会变成无效链接；

				注意：符号链接文件的大小是其指定的文件的路径字符串的字节数；

			创建：
				ln -s src link_file

				-v：verbose

回顾：磁盘、磁盘分区、文件系统

	CentOS 6,7：/dev/sd[a-z]#
	管理分区：fdisk,parted,sfdisk
	创建文件系统：
	Linux文件系统类型：ext2,ext3,ext4,xfs,reiserfs,iso9660,swap
	文件系统的组织结构中的术语：
		block groups,block,inode table,inode,inode bitmap,block bitmap,superblock

磁盘和文件系统管理


	文件系统管理工具：
		创建文件系统工具
			mkfs
				mkfs.ext2,mkfs.ext3,mkfs.ext4,mkfs.xfs,mkfs.vfat,...
		检测及修复文件系统的工具
			fsck
				fsck.ext2,fsck.ext3,...
		查看其属性的工具
			dumpe2fs,tune2fs
		调整文件系统特性：
			tune2fs

	内核及文件系统的组成部分：
		文件系统驱动：由内核提供
		文件系统管理工具：由用户空间的应用程序提供

	ext系列文件系统的管理工具：
		mkfs.ext2,mkfs.ext3,mkfs.ext4

		mkfs -t ext2 = mkfs.ext2

		ext系列文件系统专用管理工具：mke2fs
			mke2fs [options] device
				-t{[ext2|ext3|ext4]}：知名要创建的文件系统类型
					mkfs.ext4 = mkfs -t ext4 = mke2fs -t ext4

				-b{1024|2048|4096}：指明文件系统的块大小；
				-L LABEL：指明卷标；
				-j：创建有日志功能的文件系统ext3；
					mke2fs -j = mke2fs -t ext3 = mkfs -t ext3 = mkfs.ext3
				-i #：bytes-per-inode，指明inode与字节的比率；即每多少字节创建一个inode；
				-N #：直接指明要给此文件系统创建的inode的数量；
				-m #：指定预留的空间，百分比；

				-O [^]FEATURE：以指定的特性创建目标文件系统；

			e2label命令：卷标的查看与设定
				查看：e2label device
				设定：e2label device LABEL

			tune2fs命令：查看或修改ext系列文件系统的某些属性
				adjust tunable filesystem parameters on ext2/ext3/ext4 filesys‐tems；
				注意：块大小创建后不可修改；

				tune2fs [OPTIONS] device
					-l：查看超级块的内容；

					修改指定文件系统的属性：
						-j：ext2 --> ext3；
						-L LABEL：修改卷标；
						-m #：调整预留空间百分比；
						-O [^]FEATHER：开启或关闭某种特性；

						-o [^]mount_options：开启或关闭某种默认挂载选项；
							acl
							^acl

			dumpe2fs命令：显示ext系列文件系统的属性信息
				dumpe2fs [-h] device

			fsck命令：用于实现文件系统检测的工具

				因进程意外终止或系统崩溃等原因导致写入操作非正常终止时，可能会造成文件损坏；此时，应该检测并修复文件系统；建议，离线进行；

				ext系列文件系统的专用工具：
					e2fsck：check a Linux ext2/ext3/ext4 file system
						e2fsck [OPTIONS] device
							-y：对所有问题自动回答为yes；
							-f：即使文件系统处于clean状态，也要强制进行检测；

					fsck：check and repair a Linux filesystem
						-t fstype：指明文件系统类型；
							fsck -t ext4 = fsck.ext4
						-a：无须交互而自动修复所有错误；
						-r：交互式修复；

		CentOS 6如何使用xfs文件系统：
			# yum -y install xfsprogs

			事先：
				# cd /etc/yum.repos.d/
				# wget http://
				# mv CentOS-Base.repo CentOS-Base.repo.bak

			创建：mkfs.xfs
			检测：fsck.xfs

	blkid命令：
		blkid device
		blkid -L LABEL：根据LABEL定位设备
		blkid -U UUID：根据UUID定位设备

	swap文件系统：
		Linux上的交换分区必须使用独立的文件系统；
			且文件系统的System ID必须为82；

		创建swap设备：mkswap命令
			mkswap [OPTIONS] device
				-L LABEL：指明卷标
				-f：强制

	Windows无法识别Linux的文件系统；因此，存储设备需要两种系统之间交叉使用时，应该使用Windows和Linux同时支持的文件系统：fat32(vfat)；
		# mlfs.vfat device

	文件系统的使用：
		首先要“挂载”：mount命令和umount命令

		根文件系统之外的其他文件系统要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现；此关联操作极为“挂载”；此目录即为“挂载点”；
			挂载点：mount_point，用于作为另一个文件系统的访问入口；
				(1)事先存在；
				(2)应该使用未被或不会被其他进程使用到的目录；
				(3)挂载点下原有的文件将会被隐藏；

		mount命令：
			mount [-nrw] [-t vfstype] [-o options] device dir

				命令选项：
					-r：readonly，只读挂载；
					-w：read and write，读写挂载；
					-n：默认情况下，设备挂载或卸载的操作会同步更新至/etc/mtab文件中；-n用于禁止此特性；

					-t vfstype：指明要挂在的设备上的文件系统的类型；多数情况下可省略，此时mount会通过blkid来判断要挂载的设备的文件系统类型；

					-L LABEL：挂载时以卷标的方式指明设备；
						mount -L LABEL dir

					-U UUID：挂载时以UUID的方式指明设备；
						mount -U UUID dir

				-o options：挂载选项
					sync/async：同步/异步操作；
					atime/noatime：文件或目录在被访问时是否更新其访问时间戳；
					diratime/nodiratime：目录在被访问时是否更新其访问时间戳；
					remount：重新挂载；
					acl：支持使用facl功能；
						# mount -o acl device dir
						# tune2fs -o acl device

					ro：只读
					rw：读写
					dev/nodev：此设备上是否允许创建设备文件；
					exec/noexec：是否允许运行此设备上的程序文件；
					auto/noauto：
					user/nouser：是否允许普通用户挂载此文件系统；
					suid/nosuid：是否允许程序文件上的suid和sgid特殊权限生效；

					defaults：Use default options: rw, suid, dev, exec, auto, nouser, and async.

			一个使用技巧：
				可以实现将目录绑定至另一个目录上，作为其临时访问入口；
					mount --bind 源目录 目标目录

			查看当前系统所有已挂载设备：
				# mount
				# cat /etc/mtab
				# cat /proc/mounts

			挂载光盘：
				mount -r /dev/cdrom mount_point

				光盘设备文件：/dev/cdrom,/dev/dvd

			挂载U盘：
				事先识别U盘设备文件；

			挂载本地的回环设备：
				# mount -o loop /PATH/TO/SOME_LOOP_FILE MOUNT_POINT

		umount命令：
			umount device|dir

			注意：正在被进程访问到的挂载点无法被卸载；
				查看被哪个或哪些进程所占用：
					# lsof MOUNT_POINT
					# fuser -v MOUNT_POINT

					终止所有正在访问某挂载点的进程：
					#fuser -km MOUNT_POINT

	交换分区启用和禁用：
		创建交换分区的命令：mkswap

		启用：swapom
			swapon [OPTION] [DEVICE]
				-a：定义在/etc/fstab文件中的所有swap设备

		禁用：swapoff
			swapoff DEVICE

	设定除根文件系统以外的其他文件系统能够开机时自动挂载：/etc/fstab文件
		每行定义一个要挂在的文件系统及其相关属性：
			6个字段：
				(1)要挂载的设备：
					设备文件；
					LABEL
					UUID
					伪文件系统：如sysfs,proc,tmpfs等
				(2)挂载点
					swap类型的设备的挂载点为swap；
				(3)文件系统类型；
				(4)挂载选项
					defaults：使用默认挂载选项；
					如果要同时指明多个挂载选项，彼此间以逗号分隔；
						defaults,acl,noatime,noexec
				(5)转储频率
					0：从不备份；
					1：每天备份；
					2：每隔一天备份；
				(6)自检次序
					0：不自检；
					1：首先自检，通常只能是根文件系统可用1；
					2：次级自检
					...

			mount -a：可自动挂载定义在此文件中的所有支持自动挂载的设备；

	两个命令：df和du
		df命令：
			df [OPTION]... [FILE]...
				-l：仅显示本地文件的相关信息；
				-h：human-readable
				-i：显示inode的使用状态而非blocks

		du命令：
			du [OPTION]... [FILE]...
				-s：sumary
				-h：human-readable

	练习：
		1、创建一个10G的分区。并格式化为ext4文件系统；
			(1)block大小为2048；预留空间为2%，卷标为MYDATA；
			(2)挂载至/mydata目录，要求挂载时禁止程序自动运行，且不更新文件的访问时间戳；
			(3)可开机自动挂载；

		2、创建一个大小为1G的swap分区，并启动之；

回顾：文件系统管理
	管理工具：mkfs,mke2fs,e2label,tune2fs,dumpe2fs,e2fsck,blkid
		mkfs.xfs,mkfs.vfat,fsck
		mkswap,swapon,swapoff
		mount,umount,fuser,lsof
		df,du

	fstab文件：
		设备	挂载点		文件系统类型 	挂载选项 	转储频率 	自检次序

	文件系统：
		目录：文件
			元数据：inode，inode table
			数据：date blocks
				下级文件或目录的文件名与其inode对应关系

				dentry

		文件名：上级目录；

		删除文件：将此文件指向的所有data block标记为未使用状态；将此文件的inode标记为未使用；
		复制和移动文件：
			复制：新建文件；
			移动文件：
				在同一文件系统：改变的仅是其路径；
				在不同文件系统：复制数据至目标文件，并删除原文件；

		符号链接：
			权限：lrwxrwxrwx
		硬链接：指向同一个inode；

bash脚本编程

	脚本文件格式：
		第一行，顶格#!/bin/bash 
		注释信息：#
		代码注释：
		缩进，适度添加空白行；

	语言：变成语法格式，库，算法和数据结构
	编程思想：
		问题空间 --> 解空间

	变量：
		局部变量
		本地变量
		环境变量

		位置参数变量
		特殊变量

	数据类型：字符型、数值型
		弱类型：字符型

	算术运算：
		+,-.*,/,%,**

		let VAR=expression
		VAR=$[expression]
		VAR=$((expression))
		VAR=$(expr argu1 argu2 argu3)

		注意：有些时候乘法符号需要转义；

		增强型赋值：
			变量做某种算术运算后回存至此变量中；
				let i=$i+#
				let i+=#

			+=,-=,*=,/=,%=

			自增：
				VAR=$[$VAR+1]
				let VAR+=1
				let VAR++

			自减：
				VAR=$[$VAR-1]
				let VAR-=1
				let VAR--

	练习：
		1、写一个脚本
			计算/etc/passwd文件中的第10个用户和第20个用户的id号之和；
				id1=$(head -10 /etc/passwd | tail -1 | cut -d: -f3)
				id2=$(head -20 /etc/passwd | tail -1 | cut -d: -f3)

		2、写一个脚本
			计算/etc/rc.d/init.d/functions和/etc/inittab文件的空白行数之和；

				grep "^[[:space:]]*$" /etc/rc.d/init.d/functions | wc -l

	条件测试：
		判断某需求是否满足，需要由测试机制来实现；

		如何编写测试表达式以实现所需的测试
			(1)执行命令，并利用命令状态返回值来判断；
				0：成功
				1-255：失败
			(2)测试表达式
				test EXPRESSION
				[ EXPRESSION ]
				[[ EXPRESSION ]]

				注意：EXPRESSION两端必须有空白字符，否则为语法错误；

		bash的测试类型：
			数值测试
			字符串测试
			文件测试

			数值测试：数值比较
				-eq：是否等于；[ $num1 -eq $num2 ]
				-ne：是否不等于；
				-gt：是否大于；
				-ge：是否大于等于；
				-lt：是否小于；
				-le：是否小于等于；

			字符串测试：
				==：是否等于；
				>：是否大于；
				<：是否小于；
				!=：是否不等于；
				=~：左侧字符串是否能够被右侧的PATTERN所匹配；

				-z "STRING"：判断指定的字符串是否为空；空则为真，不空则假；
				-n "STRING"：判断指定的字符串是否不空；不空则真，空则为假；

				注意：
					(1)字符串要加引用；
					(2)要使用[[]]；

			文件测试：
				存在性测试
					-a FILE
					-e FILE
						文件的存在性测试，存在则为真，否则则为假；
				存在性及类型测试
					-b FILE：是否存在并且为 块设备 文件；
					-c FILE：是否存在并且为 字符设备 文件；
					-d FILE：是否存在并且为 目录文件；
					-f FILE：是否存在并且为 普通文件；
					-h FILE或 -L FILE：是否存在并且为 符号链接文件；
					-p FILE：是否存在且为 管道命名文件；
					-S FILE：是否存在且为 套接字文件；
				文件权限测试：
					-r FILE：是否存在并且 对当前用户可读；
					-w FILE：是否存在并且 对当前用户可写；
					-x FILE：是否存在并且 对当前用户可执行；
				特殊权限测试：
					-u FILE：是否存在并且 拥有suid权限；
					-g FILE：是否存在并且 拥有sgid权限；
					-k FILE：是否存在并且 拥有STICKY权限；
				文件是否有内容：
					-s FILE：是否有内容；
				时间戳：
					-N FILE：文件自从上一次读操作后是否被修改过；
				从属关系测试：
					-O FILE：当前用户是否为文件的属主；
					-G FILE：当前用户是否属于文件的属组；
				双目测试：
					FILE1 -ef FILE2：FILE1与FILE2是否为指向同一个文件系统的相同inode的硬链接；
					FILE1 -nt FILE：FILE1是否新于FILE2；
					FILE2 -ot FILE：FILE1是否旧于FILE2；

			组合测试条件：
				逻辑运算：
					第一种方式：
						COMMAND1 && COMMAND2
						COMMAND1 || COMMAND2
						!COMMAND 

						[-O FILE ] && [-r FILE]

					第二种方式：
						EXPRESSION1 -a EXPRESSION2
						EXPRESSION1 -o EXPRESSION2
						!EXPRESSION

						[-O FILE -a -x FILE]

				练习：将当前主机名称保存至hostName变量中；
					主机名如果为空，或者为localhost.localdomain，则将其设置为www.magedu.com；

					hostName=$(hostname)

					[ -z "$hostName" -o "hostName"=="localhost.localdomain" -o "$hostName"=="localhost" ] && hostname www.magedu.com

		脚本的状态返回值：
			默认是脚本中执行的最后一条命令的状态返回值；自定义状态退出状态码；
				exit[n]：n为自己指定的状态码；
					注意：shell进程遇到exit是，即会终止，因此，整个脚本执行即为结束；

	向脚本传递参数：
		位置参数变量

		myscript.sh argu1 argu2
			引用方式：
				$1,$2,...,${10},${11},...

			轮替：
				shift [n]：位置参数轮替；

		练习：写一个脚本，通过命令行传递两个文本文件路径给脚本，计算其空白行数之和；

			#!/bin/bash
			#
			file1_lines=$(grep "^$" $1 | wc -l)
			file2_lines=$(grep "^$" $2 | wc -l)

			echo "$Total blank lines: $[file1_lines+$file2_lines]"

	特殊变量：
		$0：脚本文件路径本身； 
		$#：脚本参数的个数；
		$*：所有参数；
		$@：所有参数

	过程式编程语言的代码执行顺序：
		顺序执行：逐条运行；
		选择执行：
			代码有一个分支：条件满足时才会执行；
			两个或以上的分支：只会执行其中一个满足条件的分支；
		循环执行：
			代码片段（循环体）要执行0、1或多个来回；

		选择执行：
			单分支的if语句：
				if 测试条件
				then
					代码分支
				fi

			双分支的if语句：
				if 测试条件;then
					条件为真时执行的分支
				else
					条件为假时执行的分支
				fi

		示例：通过参数传递一个用户名给脚本，此用户不存在时，则添加之；
			#!/bin/bash
			#
			if ! grep "^$1\>" /etc/passwd &> /dev/null; then
				useradd $1
				echo $1 | passwd --stdin $1 &> /dev/null
				echo "Add user $1 finished."
			fi

			#!/bin/bash
			#
			if [ $# -lt 1 ]; then
			    echo "At least one username."
			    exit 2
			fi

			if ! grep "^$1\>" /etc/passwd &> /dev/null; then
			    useradd $1
			    echo $1 | passwd --stdin $1 &> /dev/null
			    echo "Add user $1 finished."
			fi

			#!/bin/bash
			#
			if [ $# -lt 1 ]; then
			    echo "At least one username."
			    exit 2
			fi

			if grep "^$1\>" /etc/passwd &> /dev/null; then
			    echo "User $1 exists."
			else
			    useradd $1
			    echo $1 | passwd --stdin $1 &> /dev/null
			    echo "Add user $1 finished."
			fi

		练习1：通过命令行参数给定两个数字，输出其中较大的数值；
			#!/bin/bash
			#
			if [ $# -lt 2]; then
				echo "Two integers."
				exit 2
			fi

			if [ $1 -ge $2 ]; then
				echo "Max number: $1."
			else
				echo "Max number: $2."
			fi


			#!/bin/bash
			#

			if [ $# -lt 2 ]; then
			    echo "Two integers."
			    exit 2
			fi

			declare -i max=$1

			if [ $1 -lt $2 ]; then
			    max=$2
			fi

			echo "Max number: $max."

		练习2：通过命令行参数给定一个用户名，判断其ID号是偶数还是奇数；
		练习3：通过命令行参数给定两个文件名，如果某文件不存在，则结束脚本执行；都存在时返回每个文件的行数，并说明其中行数较多的文件；

RAID：
	Redundant Arrays of Inexpensive Disks
						Independent

	Berkeley：A case for Redundent Arrays of Inexpensive Disk RAID

		提高IO能力：
			磁盘并行读写；
		提高耐用性：
			磁盘冗余来实现；

		级别：多块磁盘组织在一起的工作方式有所不同；
		RAID实现的方式：
			外接式磁盘阵列：通过扩展卡提供适配能力
			内接式RAID：主板集成RAID控制器
			Software RAID：

	级别：level
		RAID-O：0，条带卷，strip;
		RAID-1：1，镜像卷，mirror;
		RAID-2
		..
		RAID-5
		RAID-6
		RAID10
		RAID01

		RAID-0：
			读、写性能提升；
			可用空间：N*min(S1,S2,...)
			无容错能力
			最少磁盘数：2，2+

		RAID-1：
			读性能提升、写性能略有下降；
			可用空间：1*min(S1,S2,...)
			有冗余能力
			最少磁盘数：2，2+

		RAID-4：
			1101，0110，1011
				  0110

		RAID-5：
			读、写性能提升
			可用空间：(N-1)*min(S1,S2,...)
			有容错能力：1块磁盘
			最少磁盘数：3，3+

		RAID-6：
			读、写性能提升
			可用空间：(N-2)*min(S1,S2,...)
			有容错能力：2块磁盘
			最少磁盘数：4，4+

		混合类型
			RAID-10：
				读、写性能提升
				可用空间：N*min(s1,s2,...)/2
				有容错能力：每组镜像最多只能坏一块；
				最少磁盘数：4，4+
			RAID-01：

			RAID-50、RAID7

			JBOD：Just a Bunch Of Disks
				功能：将多块磁盘的空间合并成一个大的连续空间使用；
				可用空间：sum(S1,S2,...)

		常用级别：RAID-0,RAID-1,RAID-5,RAID-10,RAID-50,JBOD

		实现方式：
			硬件实现方式
			软件实现方式

			CentOS 6上的软件RAID的实现：
				结合内核中的md(multi devices)

				mdadm：模式化的工具
					命令的语法格式：mdadm [mode] <raiddevice? [OPTIONS] <component-devices>
						支持的RAID级别：LINEAR,RAID0,RAID1,RAID4,RAID5,RAID6,RAID10;

					模式：
						创建：-C
						装配：-A
						监控：-F
						管理：-f,-r,-a

					<raiddevice>:/dev/md#
					<component-devices>：任意块设备

					-C：创建模式
						-n #：使用#个块设备来创建此RAID；
						-l #：指明要创建的RAID的级别；
						-a {yes|no}：自动创建目标RAID设备的设备文件；
						-c CHUNK_SIZE：指明块大小；
						-x #：指明空闲盘的个数；

						例如：创建一个10G可用空间的RAID5；

					-D：显示raid的详细信息：
						mdadm -D /dev/md#

					管理模式：
						-f：标记指定磁盘为损坏；
						-a：添加磁盘
						-r：移除磁盘

					观察md的状态：
						cat /proc/mdstat

					停止md设备：
						mdadm -S /dev/md#

				watch命令：
					-n #：刷新间隔，单位是秒；

					watch -n# 'COMMAND'

		练习1：创建一个可用空间为10G的RAID1设备，要求其chunk大小为128k，文件系统为ext4,有一个空闲盘，开机可自动挂载至/backup目录；
		练习2：创建一个可用空间为10给的RAID10设备，要求其chunk大小为256k，文件系统为ext4,开机可自动挂载至/mydata目录；

	博客作业：raid各级别特性；

LVM2：
	
	LVM：Logical Volume Manager, Version：2

	dm：device mapper，将一个或多个底层块设备组织成一个逻辑设备的模块；
		/dev/dm-#

	/dev/mapper/VG_NAME-LV_NAME
		/dev/mapper/vol0-root 
	/dev/VG_NAME/LV_NAME
		/dev/vol0/root

	pv管理工具：
		pvs：简要pv信息显示
		pvdisplay：显示pv的详细信息

		pvcreate /dev/DEVICE：创建pv

	vg管理工具：
		vgs
		vgdisplay

		vgcreate
		vgextend
		vgreduce
			先做pvmove

		vgremove

	lv管理工具
		lvs
		lvdisplay

		lvcreate -L #[mMgGtT] -n NAME VolumeGroup

		lvremove /dev/VG_NAME/LV_NAME

	扩展逻辑卷：
		# lvextend -L [+]#[mMgGtT] /dve/VG_NAME/LV_NAME
		# resize2fs /dev/VF_NAME/LV_NAME

	缩减逻辑卷：
		# umount /dev/VG_NAME/LV_NAME
		# e2fsck -f /dev/VG_NAME/LV_NAME
		# resize2fs /dev/VG_NAME/LV_NAME #[mMgGtT]
		# lvreduce -L [-]#[mMgGtT] /dve/VG_NAME/LV_NAME
		# mount

	快照：snapshot
		lvcreat -L #[mMgGtT] -p r -s -n snapshort_lv_name origibal_lv_name

文件系统挂载使用：
	挂载光盘设备：
		光盘设备文件：
			IDE：/dev/hdc
			SATA：/dev/sr0

			符号链接文件：
				/dev/cdrom
				/dev/cdrw
				/dev/dvd
				/dev/dvdrw

		mount -r /dev/cdrom /media/cdrom
		umount /dev/cdrom

	dd命令：convert and copy a file
		用法：
			dd if=/PATH/FROM/SRC of=/PATH/TO/DEST
				bs=#：block size，复制单元大小；
				count=#：复制多少个bs；

			磁盘拷贝：
				dd if=/dev/sda of=/dev/sdb

			备份MBR
				dd if=/dev/sda of=/tmp/mbr.bak bs=512 count =1

			破坏MBR中的bootloader：
				dd if=/dev/zero of=/dev/sda bs=256 count=1

		两个特殊设备：
			/dev/null：数据黑洞；
			/dev/zero：吐零机；

	博客作业：lvm基本应用，扩展及缩减实现；

回顾：lvm2,dd
	lvm：边界动态扩展或收缩；快照；
		pv --> vg --> lv
			PE：
			LE:

	dd：复制

btrfs文件系统：
	技术预览版

	Btrfs(B-tree,  Butter FS, Better FS), GPL, Oracel, 2007, CoW; 
	ext3/ext4, xfs

	核心特性：
		多物理卷支持：btrfs可由多个底层物理卷组成：支持RAID，以联机“添加”、“移除”、“修改”；
		写时复制更新机制(CoW)：复制、更新及替换指针，而非“就地”更新；
		数据及元数据校验码；
		子卷：sub_volume
		快照：支持快照的快照
		透明压缩：

	文件系统创建：
		mkfs.btrfs
			-L 'LABEL'
			-d <type>: raid0, raid1, raid5, raid6, raid10, single
			-m <profile>: raid0, raid1, raid5, raid6, raid10, single, dup
			-O <feature>
				-O list-all：列出支持的所有feature；

		属性查看：
			btrfs filesystem show

		挂载文件系统：
			mount -t btrfs /dev/sdb MOUNT_POINT

		透明压缩机制：
			mount -o compress={lzo|zlib} DEVICE MOUNT_POINT

回顾：
	RAID：Level
	LVM：Volume
	btrfs：了解；

压缩和解压缩工具和bash脚本编程；

	压缩比
		目的：时间 换 空间
			CPU的时 --> 磁盘空间

	compress/uncompress,.Z
	gzip/gunzip, .gz
	bzip2/bunzip2, .bz2
	xz/unxz, .xz
	lzma/unlzma, lzma
	zip/unzip
	tar,cpio

	1、gzip/gunzip/cat
		gzip, gunzip, zcat - compress or expand files

		gzip [OPTION]... FILE...
			-d：解压缩，相当于gunzip；
			-#：指定压缩比，默认是6；数字越大压缩比越大(1-9)；
			-c：将压缩结果输出至标准输出；
				gzip -c FILE > /PATH/TO/SOMEFILE.gz

	2、bzip2/bunzip2,bzcap

		bzip2 [OPTION]... FILE...
			-d：解压缩
			-#：制定压缩比；默认是6；数字越大压缩比越大(1-9)；
			-k：keep，保留原文件；

	3、xz/unxz/xzcat
	   	lzma/unlzma/lzcat

	  	xz [OPTION]... FILE...
	   		-d：解压缩
	   		-#：指定压缩比，默认是6；数字越大压缩比越大(1-9)；
	   		-k：保留原文件；

	归档：tar,cpio

		tar命令：
			tar [OPTION]... FILE...

			(1)创建归档
				-c -f /PATH/TO/SOMEFILE.tar FILE...
				-cf /PATH/TO/SOMEFILE.tar FILE...

			(2)展开归档
				-xf /PATH/TO/SOMEFILE.tar FILE...
				-xf /PATH/TO/SOMEFILE.tar FILE... -C /PATH/TO/SOMEDIR

			(3)查看归档文件的文件列表
				-tf /PATH/TO/SOMEFILE.tar

		归档完成后通常需要压缩，结合此前的压缩工具，就能实现压缩多个文件了；
			(4)归档并压缩
				-z：gizp2
					-zcf /PATH/TO/SOMEFILE.tar.gz FILE...
					解压缩并展开归档：-zxf /PATH/TO/SOMEFILE.tar.gz

				-j：bzip2
					-jcf
					-jxf

				-J: xz
					-Jcf
					-Jxf

	zip：
		zip/unzip
			后缀名：.zip

	练习：下载redis-3.0.2.tar.gz, 展开至/tmp目录；而后重新创建压缩为xz格式

bash脚本编程之用户交互：
	
	脚本参数

	用户交互：通过键盘输入数据，从而完成变量赋值操作；
		read [option]... [name]...
			-p prompt
			-t timeout

			#!/bin/bash
			#
			read -p "Enter a username: " name
			[ -z "$name" ] && echo "a username is needed." && exit 2

			read -p "Enter a password for $name, [password]: " password
			[ -z "$password" ] && echo password="password"

			if id $name &> /dev/null; then
			    echo "$name exists."
			else
			    useradd $name
			    echo "$password" | passwd --stdin $name &> /dev/null
			fi

	bash -n /path/to/some_script
		检测脚本中的语法错误

	bash -x /path/to/some_script
		调试执行

Linux任务计划、周期性任务执行

	未来的某时间点执行一次某任务：at, batch
	周期性运行某任务：crontab
		执行结果：会通过邮件发给用户

		~]# netstat -tnl
		~]# ss -tnl

	本地电子邮件服务：
		smtp: simple mail transmission protocol
		pop3: Post Office Procotol
		imap4: Internet Mail Access Procotol

		mail命令：
			mailx - send and receive Internet mail

				MUA: Mail User Agent, 用户收发邮件的工具程序；

				mailx [-s 'SUBJECT'] username[@hostname]
					邮件正文的生成：
						(1)交互式输入；. 单独成行可以表示正文结束；Ctrl+d提交亦可；
						(2)通过输入重定向；
						(3)通过管道；

	at命令：
		at [OPTION]... TIME

			TIME: 
				HH:MM [YYYY-mm-dd]
				noon, midnight, teatime
				tomorrow
				now+#
					UNIT: minutes,hours,days,OR weeks

			at的作业有队列，用单个字母表示，默认都使用a队列；

			常用选项：
				-l: 查看作业队列，相当于atq
				-f /PATH/FROM/SOMEFILE: 从指定文件中读取作业任务，而不用再交互式输入；
				-d：删除指定的作业，相当于atrm；
				-c: 查看制定作业的具体内容；
				-q QUEUE: 指明队列；

			注意：作业执行结果是以邮件发送给提交作业的用户；

	batch命令：
		batch会让系统自行选择在系统资源较空闲的时间去执行指定的任务；

	周期性任务计划：cron
		服务程序：
			cronie: 主程序包，提供了crond守护进程和相关辅助工具；

		确保crond守护进程(deamon)处于运行状态：
			CentOS 7:
				systemctl status crond.service
					Active: active (running)...

			CentOS 6:
				service crond status
					... is running.

		向crond提交作业的方式不同于at，它需要使用专用的配置文件，此文件有固定格式，不建议使用文本编辑器直接编辑此文件；要使用crontab命令；
			cron任务分为两类：
				系统cron任务：主要用于实现系统自身的维护；
					手动编辑：/etc/crontab文件
				用户cron任务：
					命令：crontab命令

			系统cron的配置格式：
				SHELL=/bin/bash
				PATH=/sbin:/bin:/usr/sbin:/usr/bin
				MAILTO=root

				# For details see man 4 crontabs

				# Example of job definition:
				# .---------------- minute (0 - 59)
				# |  .------------- hour (0 - 23)
				# |  |  .---------- day of month (1 - 31)
				# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
				# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
				# |  |  |  |  |
				# *  *  *  *  * user-name  command to be executed

				注意：
					(1)每一行定义一个周期性任务，共7个字段
						* * * * *：定义周期性时间
						user-name：运行任务的用户身份
						command to be executed：任务
					(2)此处的环境变量不同于用户登陆后获得的环境变量，因此，建议命令使用绝对路径，或者自定义PATH环境变量；
					(3)执行结果邮件发送给MAILTO指定的用户

			用户cron的配置格式：/var/spool/cron/USERNAME
				SHELL=/bin/bash
				PATH=/sbin:/bin:/usr/sbin:/usr/bin
				MAILTO=root

				# For details see man 4 crontabs

				# Example of job definition:
				# .---------------- minute (0 - 59)
				# |  .------------- hour (0 - 23)
				# |  |  .---------- day of month (1 - 31)
				# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
				# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
				# |  |  |  |  |
				# *  *  *  *  * command to be executed

				注意：
					(1)每行定义一个cron任务，共6字段；
					(2)此处的环境变量不同于用户登陆后获得的环境变量，因此，建议命令使用绝对路径，或者自定义PATH环境变量；
					(3)邮件发送给当前用户；

			时间表示法：
				(1)特定值：
					给定时间有效取值范围内的值；
						注意：day of week和day of month一般不同时使用；
				(2)*
					给定时间点上有效取值范围内的所有值；表“每..”
				(3)离散取值：,
					在时间点上使用逗号分割的多个值；
						#,#,#
				(4)连续取值：-
					在时间点上使用-连接开头和结束
						#-#
				(5)在指定时间点上，定义步长: 
					/#：#即步长；

					注意：
						(1)指定的时间点不能被步长整除时，其意义将不服存在；
						(2)最小时间单位为“分钟”，想完成“秒”级任务，得需要额外借助于其他机制；
							定义成每分钟任务；而后利用脚本实现在每分钟之内，循环执行多次；

			示例：
				(1)3 * * * *: 每小时执行一次；每小时的第3分钟；
				(2)3 4 * * 5：每周执行一次；每周5的4点3分；
				(3)5 6 7 * *：每月执行一次；每月的7号的6点5分；
				(4)7 8 9 10 *：每年执行一次，每年的10月9号8点7分；
				(5)9 8 * * 3,7：每周三和周日；
				(6)0 8,20 * * 3,7；
				(7)0 9-18 * * 1-5：
				(8)*/5 * * * *：每5分钟执行一次某任务；
				(9)*/7

			crontab命令：
				crontab [-u user] [-l | -r | -e] [-i] 
					-e：编辑任务；
					-l：列出所有任务；
					-r：移除所有任务；即删除/var/spool/cron/USERNAME文件；
					-i：在使用-r选项移除所有任务时提示用户确认；
					-u user：root用户可为指定用户管理cron任务；

			注意：运行结果以邮件通知给当前用户；如果拒绝接收邮件：
				(1)COMMAND > /dev/null
				(2)COMMAND &> /dev/null

			注意：定义COMMAND时，若果命令需要用到%，需要对其转义；但放置于单引号中的%不用转义亦可；

			思考：某任务在指定的时间因关机未能执行，下次开机会不会自动执行？
				不会！
				如果某时间点因故未能按时执行，下次开机后无论是否到了相应时间点都要执行一次，可使用anacron实现；

			课外作业：anacron及其应用；

	练习：
		1、每12小时备份一次/etc目录至/backups目录中，保存文件 名称格式为 “etc-yyyy-mm-dd-hh.tar.gz”
		2、每周2、4、7备份/var/log/secure文件至/logs目录中，文件名格式为“secure-yyyymmdd”
		3、每两小时去除当前系统/proc/meminfo文件中以S或M开头的行信息追加至/tmp/meminfo.txt文件中；

		12,24 * * * tar zcf /backups/etc-yyyy-mm-dd-hh.tar.gz /etc
     	0 0 * * 2,4,7 tar cf /logs/secure-yyyymmdd.tar /var/log/secure

Linux程序包管理

	概述：
		API：Application Program Interface
		ABI：Application Binary Interface
			Unix-like,
				ELF
			Windows
				exe, msi

			库级别的虚拟化：
				Linux: WinE
				Windows: Cywin

		系统级开发：
			C/C++：httpd, vsftpd, nginx
			go
		应用级开发：
			java/Python/perl/ruby/php：
				java: hadoop, hbase, (jvm)
				Python：openstack, (pvm)
				perl:(perl)
				ruby:(ruby)
				php:(php)

		C/C++程序格式：
			源代码：文本格式的程序代码；
				编译开发环境：编译器、头文件、开发库
			二级制格式：文本格式的程序代码 --> 编译器 --> 二进制格式(二进制程序、库文件、配置文件、帮助文件)

		java/Python程序格式：
			源代码：编译成能够在其虚拟机(jvm/pvm)运行的格式；
				开发环境：编译器、开发库
			二进制

		项目构建工具：
			c/c++: make
			java: maven

	程序包管理器：
		源代码 --> 目标二进制格式(二进制程序、库文件、配置文件、帮助文件) --> 组织成为一个或有限几个“包”文件；
			安装、升级、卸载、查询、校验

		程序包管理器：
			debian：dpt, dpkg, ".deb"
			redhat：redhat package manager, rpm, ".rpm"；rpm is package manager；
			S.u.S.E：rpm, ".rpm",

			Gentoo：ports
			ArchLinux：

		源代码：name-VERSION.tar.gz 
			VERSION：major.minor.release
		rpm包命令格式：
			name-VERSION-release.arch.rpm 
				VERSION：major.minor.release
				release.arch：rpm包的发行号
					release.os：2.el7.i386.rpm
					archetecture：i386, x64(amd64), ppc, noarch

				redis-3.0.2.tar.gz --> redis-3.0.2-1.centos7.x64.rpm 

			拆包：主包和支包
				主包：name-VERSION-release.arch.rpm
				支包：name-function-VERSION-release.arch.rpm
					function:devel, utils, libs, ...

		依赖关系：
			X, Y, Z

				X --> Y,Z
					Y --> A, B, C
					C --> Y

			前端工具：自动解决依赖关系；
				yum：rhel系列系统上rpm包管理器的前端工具；
				apt-get(apt-catch)：deb包管理器的前端工具；
				zypper：suse的rpm管理器前端工具；
				dnf：Fedora 22+系统上rpm包管理器的前端工具；

		程序包管理器：
			功能：将编译好的应用程序的各组成文件打包成一个或几个程序包文件，从而更方便地实现程序包的安装、升级、卸载和查询等管理操作；

			1、程序包的组成清单(每个程序包都单独实现)；
				文件清单
				安装或卸载时运行的脚本
			2、数据库（公共）
				程序包的名称和版本；
				依赖关系；
				功能说明；
				安装生成的各文件的文件路径及校验码信息；
				等等等

				/var/lib/rpm/

	获取程序包的途径：
		(1)系统发行版的光盘或官方的文件服务器（或镜像站点）；
			http://mirrors.aliyun.com,
			http://mirrors.sohu.com,
			http://mirrors.163.com
		(2)项目的官方站点
		(3)第三方组织：
			(a)EPEL
			(b)搜索引擎
				http://pkgs.org
				http://rpmfind.net
				http://rpm.pbone.net

		(4)自己动手，丰衣足食

		建议：检查其合法性
			来源合法性；
			程序包的完整性；

	CentOS系统上rpm命令管理程序包：
		安装、升级、卸载、查询和校验、数据库维护

		rpm命令：rpm [OPTIONS] [PACKAGE_FILE]
			安装：-i, --install
			升级：-U, --update, -F, --freshen
			卸载：-e, --erease
			查询：-q, --query
			校验：-V, --verify
			数据库维护：--builddb, initdb

		安装：
			rpm {-i|--install} [install-options] PACKAGE_FILE ...

				rpm -ivh PACKAGE_FILE

				GENERAL OPTIONS：
					-v：verbose，详细信息
					-vv：更详细的输出

				[install-options]：
					-h：hash marks输出进度条；每个#表示2%的进度；
					--test：测试安装，检查并报告依赖关系及冲突消息等；
					--nodeps：忽略依赖关系；不建议；
					-replacepkgs：重新安装；

					注意：rpm可以自带脚本；
						四类：--noscripts
							preinstall：安装过程开始之前运行的脚本，%pre, --nopre
							postinstall：安装过程完成之后运行的脚本，%post, --nopost
							preuninstall：卸载过程真正开始执行之前运行的脚本，%preun, --nopreun
							postuninstall：卸载过程完成之后运行的脚本，%postyn, --nopostun

					--nosignature：不检查包签名信息，不检查来源合法性；
					--nodegist：不检查包完整信息；

		升级：
			rpm {-U|--upgrade} [install-options] PACKAGE_FILE ...
			rpm {-F|--freshen} [install-options] PACKAGE_FILE ...
				-U：升级或安装；
				-F：升级

				rpm -Uvh PACKAGE_FILE ...
				rpm -Fvh PACKAGE_FILE ...

					--oldpackage：降级；
					--force：强制升级；

				注意：(1)不要对内核做升级操作；Linux支持多内核版本并存，因此，直接安装新版本内核；
					  (2)如果某源程序包的配置文件安装后曾被修改过，升级时，新版本的程序提供的同一个配置文件不会覆盖原有版本的配置文件，而是把新版本的配置文件重命名(FILENAME.rpmnew)后提供；

		卸载：
			rpm {-e|--erase} [--allmatches]  [--justdb]  [--nodeps]  [--noscripts] [--test] PACKAGE_NAME ...

				--allmatcher：卸载所有匹配指定名称的程序包的各版本；
				--nodeps：忽略依赖关系；
				--test：测试卸载，dry run模式

		查询：
			rpm {-q|--query} [select-options] [query-options]


			[select-options]
				PACKAGE_NAME：查询指定的程序包是否已经安装，及其版本；
				-a, --all：查询所有已经安装过的包；
				-f FILE：查询指定的文件由哪个程序包安装生成；

				-p, --package PACKAGE_FILE：用于实现对未安装的程序包执行查询操作；

				--whatprovides CAPABILITY：查询指定的CAPABILITY由哪个程序包提供；
				--whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖；

			[query-options]
				--changelog：查询rpm包的changelog；
				-l, --list：程序安装生成的所有文件列表；
				-i, --info：程序包相关的信息，版本号、大小、所属的包组，等；
				-c, --configfiles：查询指定的程序提供的配置文件；
				-d, --docfiles：查询指定的程序包提供的文档；
				--provides：列出指定的程序包提供的所有的CAPABILITY
				-R, --requires：查询指定的程序包的依赖关系；
				--scripts：查看程序包自带的脚本片段；

			用法：
				-qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE
				-qpi PACKAGE_FILE, -qpl PACKAGE_FILE, -qpc PACKAGEFILE, ...

		校验：
			rpm {-V|--verify} [select-options] [verify-options]

			S file Size differs
	        M Mode differs (includes permissions and file type)
	        5 digest (formerly MD5 sum) differs
	        D Device major/minor number mismatch
	        L readLink(2) path mismatch
	        U User ownership differs
	        G Group ownership differs
	        T mTime differs
	        P caPabilities differ

	包来源合法性验证和完整性验证：
		来源合法性验证：
		完整性验证：

		获取并导入信任的包制作者的的密钥：
			对于CentOS发行版来说；rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

		验证：
			(1)安装此组织签名的程序时，会自动执行验证；
			(2)手动验证：rpm -K PACKAGE_FILE

	数据库重建：
		rpm管理器数据库路径：/var/lib/rpm/
			查询操作：通过此处的数据库进行；

		获取帮助：
			CentOS6：man rpm
			CentOS7：man rpmdb

			rpm {--initdb|--rebuilddb}
				--initdb：初始化数据库，当前无任何数据库可初始化创建一个新的；当前有时不执行任何操作；
				-rebuilddb：重新构建，通过读取当前系统上所有已经安装过的程序包进行重新创建；

	博客作业：rpm包管理功能全解；

回顾：Linux程序包管理的实现、rpm包管理器

	rpm命令实现程序管理：
		安装：-ivh, --nodeps, --replacepkgs
		卸载：-e, --nodeps
		升级：-Uvh, -Fvh, --nodeps, --oldpackage
		查询：-q, -qa, -qf, -qi, -qd, -qc, -q --scripts, -q --changlog, -q --provides, -q --requires
		校验：-V

		导入GPG密钥：--import, -K, --nodigst, --nosignature
		数据库重建：--initdb, --rebuilddb

Linux程序包管理(2)

	CentOS：yum, dnf

	URL：ftp://172.16.0.1/pub/

	YUM：yellow dog, Yellow Update Modifier

	yum reposistory: yum repo
		存储了众多rpm包，以及包的相关的元数据文件(放置于特定目录下：repodata)；

		文件服务器：
			ftp://
			http://
			nfs://
			file:///

	yum客户端
		配置文件：
			/etc/yum.conf：为所有仓库提供公共配置
			/etc/yum.repos.d/*.repo：为仓库的指向提供配置

		仓库指向的定义：
		[repositoryID]
		name=Some name for this repository
		baseurl=url://path/to/repository/
		enabled={1|0}
		gpgcheck]{1|0}
		gpgkey=URL
		enablegroups={1|0}
		failovermethod={roundrobin|priority}
			默认为：roundwobin：意为随机
		cost=#
			#默认为1000

		yum源：？？？

			[base]
			name=Base Repo on url
			baseurl=url
			gpgcheck=0

			[epel]
			name=Fedora EPEL for EL6 x86_64
			baseurl=url
			gpgcheck=0

	yum命令的用法：
		yum [options] [command] [package ...]

       command is one of:
        * install package1 [package2] [...]
        * update [package1] [package2] [...]
        * update-to [package1] [package2] [...]
        * update-minimal [package1] [package2] [...]
        * check-update
        * upgrade [package1] [package2] [...]
        * upgrade-to [package1] [package2] [...]
        * distribution-synchronization [package1] [package2] [...]
        * remove | erase package1 [package2] [...]
        * autoremove [package1] [...]
        * list [...]
        * info [...]
        * provides | whatprovides feature1 [feature2] [...]
        * clean [ packages | metadata | expire-cache | rpmdb | plugins | all]
        * makecache [fast]
        * groups [...]
        * search string1 [string2] [...]
        * shell [filename]
        * resolvedep dep1 [dep2] [...]
           (maintained for legacy reasons only - use repoquery  or  yum  pro‐vides)
        * localinstall rpmfile1 [rpmfile2] [...]
           (maintained for legacy reasons only - use install)
        * localupdate rpmfile1 [rpmfile2] [...]
           (maintained for legacy reasons only - use update)
        * reinstall package1 [package2] [...]
        * downgrade package1 [package2] [...]
        * deplist package1 [package2] [...]
        * repolist [all|enabled|disabled]
        * repoinfo [all|enabled|disabled]
        * repository-packages  <enabled-repoid>  <install|remove|remove-or-reinstall|remove-or-distribution-synchronization> [package2] [...]
        * version [ all | installed | available | group-* | nogroups* | grou‐plist | groupinfo ]
        * history   [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats]
        * load-transaction [txfile]
        * updateinfo [summary | list  |  info  |  remove-pkgs-ts  |  exclude-
       updates | exclude-all | check-running-kernel]
        * fssnapshot [summary | list | have-space | create | delete]
        * fs [filters | refilter | refilter-cleanup | du]
        * check
        * help [command]

    显示仓库列表：
    	repolist [all|enabled|disabled]

    显示程序包：
    	list
    		# yum list [all | glob_exp1] [glob_exp2] [...]
    		# yum list {available|installed|updates} [glob_exp1] [...]

    安装程序包：
    	install package1 [package2] [...]

    	reinstall package1 [package2] [...]（重新安装）

    升级程序包：
    	update [package1] [package2] [...]

    	downgrade package1 [package2] [...]（降级）

    检查可用升级：
    	check-update

    卸载程序包：
    	remove | erase package1 [package2] [...]

    查看程序包information：
    	info [...]

    查看指定的特性（可以是某文件）是由哪个程序包所提供：
    	provides | whatprovides feature1 [feature2] [...]

    清理本地缓存：
    	clean [ packages | metadata | expire-cache | rpmdb | plugins | all]

    构建缓存：
    	makecache [fast]

    搜素：
    	search string1 [string2] [...]

    	以指定的关键字搜索程序包名及summary信息；

    查看指定包所依赖的capabilities：
    	deplist package1 [package2] [...]

    查看yum事务历史：
    	history   [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats]

    安装及升级本地程序包：
    	localinstall rpmfile1 [rpmfile2] [...]
    		(maintained for legacy reasons only - use install)
    	localupdate rpmfile1 [rpmfile2] [...]
    		(maintained for legacy reasons only - use update)

    包组管理的相关命令：
    	groups [...]

    如何使用光盘当作本地YUM仓库：
    	（1）挂载光盘至某目录，例如/media/cdrom
    		# mount -r -t iso9660 /dev/cdrom /media/cdrom
    	（2）创建配置文件
    		[CentOS7]
    		name=
    		baseurl=
    		gpgcheck=
    		enabled=

    yum的命令行选项：
    	--nogpgcheck：禁止运行gpg check；
    	-y：自动回答为"yes"；
    	-q：静默模式；
    	--disablerepo=repoidglob：临时禁用此处指定的repo；
    	--enablerepo=repoidglob：临时启用指定repo；
    	--noplugins：禁用所有插件；

    yum的repo配置文件中可用的变量：
    	$releasever：当前OS的发行版的主版本号；
    	$arch：平台；
    	$basearch：基础平台；
    	$YUM0-$YUM9

    	http://mirrors.163.com/centos/$releasever/$basearch/os

    创建yum仓库：
    	createrepo [options] <directory>

    程序包编译安装：
    	testapp-VERSION-release.src.rpm --> 安装后使用rpmbuild命令制作成二进制格式的rpm包，而后再安装；

    	源代码 --> 预处理 --> 编译(gcc) --> 汇编 --> 链接 --> 执行

    	源代码组织格式：
    		多文件：文件中的代码之间，很可能存在跨文件依赖关系；

    		C、C++：make --> (configure --> Makefile.in --> makefile)
    		java：maven

    		C代码编译安装三步骤：
    			./configure：
    				(1) 通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的指定以及Makefile.in文件生成makefile；
    				(2) 检查各依赖到的外部环境；
    			make：
    				根据makefile文件，构建应用程序；
    			make install：

    		开发工具：
    			auotoconf：生成configure脚本
    			auotomake：生成Makefile.in

    		建议：安装前查看INSTALL, README

    	开源程序源代码获取；
    		官方自建站点：
    			aoache.org(ASF)
    			mariadb.org
    			...
    		代码托管：
    			SourceForge
    			Github.com
    			code.google.com

    	c/c++: gcc (GNU C Complier)

    	编译C源代码：
    		前提：提供开发工具及开发环境
    			开发工具：make, gcc等
    			开发环境：开发库，头文件
    				gilbc：标准库

    			通过“包组”提供开发组件
    				CentOS 6："Development Tools", "Server Platforem Development"

    		第一步：Configure脚本
    			选项：指定安装位置、指定启用的特性

    			--help：获取其支持使用的选项
    				选项分类：
    					安装路径设定：
    						--prefix=/PATH/TO/SOMEWHERE：指定默认安装位置；默认为/usr/local
    						--sysconfdir=/PATH/TO/SOMEWHERE：配置文件安装位置；

    					System types：

    					Optional Features：可选特性
    						--disable-FEATURE
    						--enable-FEATURE[=ARG]

    					Optional Packages：可选程序包
    						--with-PACKAGE[=ARG]
    						--without-PACKAGE

    		第二步：make

    		第三步：make install

    	安装后的配置：
    		(1) 导出二进制程序目录至PATH环境变量中；
    			编辑文件/etc/profile.d/NAME.sh
    				export PATH=/PATH/TO/BIN:$PATH

    		(2) 导出库文件路径
    			/etc/ld.so.conf.d/NAME.conf
    				添加新的库文件所在目录至此文件中；

    			让系统重新生成缓存：
    				ldconfig [-v]

    		(3) 导出头文件
    			基于连接的方式实现：
    				ln -sv 

    		(4) 导出帮助手册
    			编辑/etc/man.config文件
    				添加一个MANPATH路径

    练习：
    	1、yum的配置和使用；包括yum repository的创建；
    	2、编译安装apache 2.2；启动此服务；

    博客作业：程序包管理：rpm/yum/编译

桌面环境：
	Windows 7, OpenSUSW 13.2, Kubuntu(KDE)

回顾：yum程序包管理器和编译安装

	C/S：
		yum client(yum)
		yum repository(ftp/http/https)

	base：
	extras
	updates

	repo：
		[id]
		name=
		baseurl=http://
			http://
		gpgcheck=

	子命令：
		list, clean, makecache, grouplist, info, whatprovides
		install, update, remove, groupinstall, groupupdate, groupgroupinfo

		yum install /usr/local/sec/testapp-3.2.1-1.el7.x86_64.rpm
			file:///

	编译安装：
		C/C++
			./configure --> makefile.in ==> makefile
				make + makefile ==> binary, library, configfile, manual
				make install

		perl, Python, Java

bash脚本编程

	过程式编程语言的执行流程：
		顺序执行
		选择执行
		循环执行

	选择执行：
		(1)&&, ||
		(2)if语句
		(3)case语句

		if语句：三种格式
			单分支的if语句
				if CONDITION; then
					if-true-分支;

				fi

			双分支的if语句
				if CONDITION; then
					if-true-分支
				else
					if-false-分支
				fi

			多分支的if语句
				if CONDITION1; then
					条件1为真分支
				elif CONDITION2; then
					条件2为真分支
				elif CONDITION3; then
					条件3为真分支
				...
				elif CONDITIONn; then
					条件n为真分支
				else
					所有条件均不满足时的分支
				fi

				注意：即便多个条件可能同时都能满足，分支只会执行其中一个，首先测试为“真”；

				示例：脚本参数传递一个文件路径给脚本，判断此文件的类型；

					#!/bin/bash
					#
					if [ $# -lt 1 ]; then
					    echo "At least one path."
					    exit 1
					fi

					if ! [ -e $1 ]; then
					    echo "No such file."
					    exit 2
					fi

					if [ -f $1 ]; then
					    echo "Common file."
					elif [ -d $1 ]; then
					    echo "Directory"
					elif [ -L $1 ]; then
					    echo "Symbolic link."
					elif [ -b $1 ]; then
					    echo "block special file"
					elif [ -c $1 ]; then
					    echo "character special file"
					elif [ -S $1 ]; then
					    echo "Socket file"
					else
					    echo "Unknown"
					fi

					注意：if语句可嵌套；

			练习：写一个脚本
				(1) 传递一个参数给脚本，此参数为用户名；
				(2) 根据其ID号来判断用户类型；
					0：管理员
					1-999：系统用户
					1000+：登陆用户

					#!/bin/bash
					#
					[ $# -lt 1 ] && echo "At least one user name." && exit 1

					! id $1 & /dev/null && echo "No such user." && exit 2

					userid=$(id -u $1)

					if [ $userid -eq 0 ]; then
					    echo "root"
					elif [ $userid -ge 1000 ]; then
					    echo "login user"
					else 
					    echo "System user."
					fi

			练习：写一个脚本
				(1)列出如下菜单给用户：
					disk) show disks info;
					mem) show memory info;
					cpu) show cpu info;
					*) quit;
				(2)提示用户给出自己的选择，而后显示对应其选择的相应系统信息；

					#!/bin/bash
					#
					cat << EOF
					disk) show disks info
					mem) show memory info
					cpu) show cpu info
					*) QUIT
					EOF

					read -p "Your choice: " option
					if [[ "$option" == "disk" ]]; then
					    fdisk -l /dev/[shv]d[a-z]
					elif [[ "$option" == "mem" ]]; then
					    free -m
					elif [[ "$option" == "cpu" ]]; then
					    lscpu
					else
					    echo "Unkown option."
					    exit 3
					fi

	循环执行：将一段代码重复执行0、1或多次；
		进入条件：条件满足时才进入循环；
		退出条件：每个循环都应该有退出条件，以有机会退出循环；

		bash脚本：
			for循环
			while循环
			until循环

		for循环：
			两种格式：
				(1)遍历列表
				(2)控制变量

			遍历列表：
				for VARAIBLE in LIST; do
					循环体
				done

				进入条件：只要列表有元素，即可进入循环；
				退出条件：列表中的元素遍历完成； 

				LISTT的生成方式：
					(1) 直接给出；
					(2) 整数列表
						(a){start..end}
						(b)seq [start [incremtal]] last
					(3) 返回列表的命令
					(4) glob
					(5) 变量引用
						$@,$*
					...

				#!/bin/bash
				#
				for username in user21 user22 user23; do
					if id $username &> /dev/null; then
						echo "$username exists."
					else
						useradd $y=username && echo "Add user $username finished."
					fi
				done

				示例：求100以内所有正整数之和；
					#!/bin/bash
					#
					declare -i sum=0

					for i in {1..100}; do
					   echo "\$sum is $sum, \$i is $i "
					   sum=$[$sum+$i]
					done

					echo $sum

				示例：判断/var/log目录下的每一个文件的内容类型
				#!/bin/bash
				#
				for filename in /var/log/*; do
				    if [ -f $filename ]; then
				        echo "Common file."
				    elif [ -d $filename ]; then
				        echo "Directory"
				    elif [ -L $filename ]; then
				        echo "Symbolic link."
				    elif [ -b $filename ]; then
				        echo "block special file"
				    elif [ -c $filename ]; then
				        echo "character special file"
				    elif [ -S $filename ]; then
				        echo "Socket file"
				    else
				        echo "Unknown"
				    fi
				done

			练习：
				1、分别求100以内所有偶数之和，以及所有奇数之和；
				2、计算当前系统上的所有用户的id之和；
				3、通过脚本参数传递一个目录给脚本，而后计算此目录下所有文本文件的行数之和；并说明此类文件的总数；

sed命令：

	文本处理三剑客：
		grep,egrep,fgrep：文本过滤器
		sed：Stream EDitor，流编辑器，行
		awk：文本格式化工具，报告生成器

	sed [OPTION]... 'script' [input-file] ...
		script：
			地址定界编辑命令

		常用选项：
			-n：不输出模式空间中的内容至屏幕；
			-e script, --expression=script：多点编辑；

				~]# sed -e '/^UUID/d' -e 's@^#[[:space:]]*@@' /etc/fstab

			-f /PATH/TP/SED_SCRIPT_FILE
				每行一个编辑命令；
			-r, --regexp-extended：支持使用扩展正则表达式；
			-i[SUFFIX], --in-place[=SUFFIX]：直接编辑原文件；

		地址定界：
			(1) 空地址：对全文进程处理；
			(2) 单地址：
				#：指定行；
				/pattern/：被此模式所匹配到的每一行；
			(3) 地址范围
				#,#：
				#,+#：
				#,/pat1/
				/pat1/,/pat2/
				$：最后一行

			(4) 步进：~
				1~2：所有奇数行
				2~2：所有偶数行

		编辑命令：
			d：删除；
			p：显示模式空间中的内容；
			a \text：在行后面追加文本"text",支持使用\n实现多行追加；
			i \text：在行前面插入文本"text",支持使用\n实现多行插入；
			c \text：把匹配到的行替换为此处指定的文本"text"；
			w /PATH/TO/SOMEFILE：保存模式空间匹配到的行至至指定的文件中；
			r /PATH/FROM/SOMEFILE：读取指定文件的内容至当前文件被模式匹配到的行处；文件合并；
			=：为模式匹配到的行打印行号；
			!：条件取反；
				地址定界!编辑命令；
			s///：查找替换，其分隔符可自行指定，常用的有s@@@,s###等；
				替换标记：
					g：全局替换；
					w /PATH/TO/SOMEFILE：将替换成功的结果保存至指定文件中；
					p：显示替换成功的行；

				练习1：删除/boot/grub/grub2.cfg文件中所有以空白字符开头的行的行首的所有空白字符；
					~]# sed 's@^[[:space:]]\+@@' /etc/grub2.cfg
				练习2：删除/etc/fstab文件中所有以#开头的行首的#及#后的所有空白字符；
					~]# sed 's@^#[[:space:]]*@@' /etc/fstab 
				练习3：输出一个绝对路径给sed命令，去除其目录，其行为类似于dirname；
					~]# echo "/var/log/messages" | sed 's@[^/]\+/\?$@@'
					~]# echo "/var/log/messages" | sed -r 's@[^/]+/?$@@'

		高级编辑命令：
			h：把模式空间中的内容覆盖至保持空间中；
			H：把模式空间中的内容追加至保持空间中；
			g：把保持空间中的内容覆盖至模式空间中；
			G：把保持空间中的内容追加至模式空间中；
			x：把模式空间中的内容与保持空间中的内容互换；
			n：覆盖读取匹配到的行的下一行至模式空间中；
			N：追加读取匹配到的行的下一行至模式空间中；
			d：删除模式空间中的行；
			D：删除多行模式空间中的所有行；

			示例：
				sed -n 'n;p' FILE：显示偶数行；
				sed '1!G;h;$!d' FILE：逆序显示文件的内容；
				sed '$!d' FILE ：取出最后一行；
				sed '$!N;$!D' FILE：取出文件后两行；
				sed '/^$d;G' FILE：删除原有的所有空白行，而后为所有的非空白行后添加一个空白行；
				sed 'n;d' FILE：显示奇数行；
				sed 'G' FILE：在原有的每行后方添加一个空白行；

		博客作业：sed的用法；
			
Linux网络属性配置

	计算机网络：
		TCP/IP：协议栈(使用)
			ISO，OSI：协议栈(学习)

		MAC：Media Access Control
			48bits：
				ICANN：24bits,2^24
					地址块：2^24

				网桥(bridge)：MAC地址表
					静态指定：
					动态学习：根据原地址学习；

				交换机(switch)：多端口网桥；

			IP(Internet protocol)地址：网络号+主机号
				A<-->B
					网络 ?
					主机 ?

				IPv4：32bits
					8bits.8bits.8bits.8bits
						0-255
						0.0.0.0-255.255.255.255

					IP地址分类：
						A类：
							第一段为网络号，后三段为主机号
							网络号：
								0 000 0000 - 0 111 1111 ：1-127
							网络数量：126，127
							每个网络中的主机数量：2^24-2
							默认子网掩码：255.0.0.0，/8
								用于与IP地址按位进行“与”运算，从而取出其网络地址；
									1.3.2.1/255.0.0.0 = 1.0.0.0
									1.3.2.1/255.255.0.0 = 1.3.0.0
							私网地址：10.0.0.0/255.0.0.0
						B类：
							前两段为网络号，后两端为主机号
							网络号：
								10 00 0000 - 10 11 1111 ：128 - 191
								网络数：2^14
								每个网络中的主机数量：2^16-2
								默认子网掩码：255.255.255.0，/16
								私网地址：172.16.0.0-172.31.0.0
						C类：
							前三段为网络号，最后一段为主机号
							网络号：
								110 0 0000 - 110 1 1111：192-223
							网络数量：2^21
							每个网络中的主机数量：2^8-2
							默认子网掩码：255.255.255.0，/24
						D类：组播
							1110 0000 - 1110 1111：224-239
						E类：科研
							240-255
				IPv6: 128bits

					路由器：router
						路由表：
							静态指定
							动态学习：rip2, ospf

						路由条目：
							目标地址 下一跳(nexthop)
								目标地址的类别：
									主机：主机路由
									网路：网络路由
									0.0.0.0/0.0.0.0：默认路由

	OS：多用户，多任务
		多任务：多进程
			chrome：
			QQ：
			QQ Music：

		通信时，进程的数字表示：
			16bits：
				0-65535：1-65535
					1-1023：固定分配，而且只有管理员有权限启动；
					1024-49151：半固定，
					49152+：临时；
		进程地址：
			IP:PORT,socket

	总结：
		MAC：本地通信；范围：本地局域网；
		IP：界定通信主机，源和目标；范围：互联网；
		Port：界定进程；范围：主机；

	将Linux主机接入到网络中：
		IP/NETMASK：本地通信
		路由（网关）：跨网络通信
		DNS服务器地址：基于主机名的通信
			主DNS服务器地址
			备用DNS服务器地址
			第三备份DNS服务器地址

		配置方式：
			静态指定：
				命令：
					ifcfg家族：
						ifconfig：配置IP，NETMASK
						route：路由
						netstat：状态及统计数据查看
					iproute2家族：
						ip OBJECT：
							addr：地址和掩码；
							link：接口
							route：路由
						ss：状态及统计数据查看
					CentOS 7：nm(Network Manager)家族
						nmcli：命令行
						nmtui：text window 工具

					注意：
						(1)DNS服务器指定
							配置文件：/etc/resolv.conf
						(2)本地主机名配置
							hostname
							配置文件：/etc/sysconfig/network
							CentOS 7：hostnamectl
				配置文件：
					RedHat及相关发行版
						/etc/sysconfig/network-scripts/ifcfg-NETCARD_NAME

			动态分配：依赖于本地网络中有DHCP服务
				DHCP：Dynamic Host Configure Procotol

	网络接口命名方式：
		传统命名：
			以太网：ethX,[0,oo),例如eth0,eth1,...
			PPP网络：pppX,[0,...],例如，ppp0,ppp1,...

		可预测命名方案(CentOS)
			支持多种不同的命名机制：
				Fireware,拓扑结构

			(1)如果Firmware或BIOS为主板上集成的设备提供的索引信息可用，则根据此索引进行命名，如eno1,eno2,...
			(2)如果Firmware或BIOS为PCI-E扩展槽所提供的索引信息可用，且可预测，则根据此索引进行命名，如ens1,ens2,...
			(3)如果硬件接口的物理位置信息可用，则根据此信息命名，如enp2s0,...
			(4)如果用户显式定义，也可根据MAC地址命名，例如enx122161ab2e10,...
			上述均不可用，则仍使用传统方式命名；

			命名格式的组成：
				en：ethernet
				wl：wl
				ww：wwan

				名称的类型：
					o<index>：集成设备的设备索引号；
					s<slot>：扩展槽的索引号；
					x<MAC>：基于MAC地址的命名；
					p<bus>s<slot>：基于总线及槽的拓扑结构进行命名；

回顾：计算机网络基础、Linux网络属性配置
	TCP/IP协议栈：物理层、互联网层、传输层、应用层
		互联网层：IP
		传输层：TCP , UDP
		应用层：http, https, ftp, ldap,...

	链路层：以太网帧
	互联网层：IP报文

	以太网帧：MTU(1500)

	Linux网络属性配置：命令，配置文件；

Linux网络属性配置(2)

	ifcfg命令家族：ifconfig, route, netstat

		ifconfig命令：接口及地址查看和管理
			ifconfig [INTERFACE]
				# ifconfig -a：显示所有接口，包括inactive状态的接口；

			ifconfig interface [aftype] options | address...
				# ifconfig IFACE IP/MASK [up|down]
				# ifconfig IFACE IP netmask NETMASK 

				options：
					[-]promisc

				注意：立即送往内核中的TCP/IP协议栈，并生效；

			管理IPv6地址：
				add addr/prefixlen
				del addr/prefixlen

		route命令：路由查看及管理

			路由条目类型：
				主机路由：目标地址为单个IP；
				网络路由：目标地址为IP网络；
				默认路由：目标为任意主机，0.0.0.0/0.0.0.0

			查看：
				# route -n
			添加：
				route add [-net|-host] target [netmask Nm] [gw Gw] [[dev] If]

					示例：route add -net 10.0.0.0/8 gw 192.168.10.1 dev eth1
						  route add -net 0.0.0.0/0.0.0.0 gw 192.168.10.1 
						  route add default gw 192.168.10.1 

			删除：
				route del [-net|-host] target [gw Gw] [net‐mask Nm] [[dev] If]

					示例：route del -net 10.0.0.0/8 gw 192.168.10.1
						  route del default

		netstat命令：
			Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships

			显示路由表：netstat -rn
				-r：显示内核路由表
				-n：数字格式

			显示网络连接：
				netstat [--tcp|-t] [--udp|-u] [--udplite|-U] [--sctp|-S] [--raw|-w] [--listening|-l] [--all|-a] [--numeric|-n] [--extend|-e[--extend|-e]] [--program|-p] 
					-t：TCP协议的相关连接，连接均有其状态；FSM(Finate State Machine)；
					-u：UDP协议相关的连接
					-w：raw socket相关的连接
					-l：处于监听状态的连接
					-a：所有状态
					-n：一数字格式显示IP和Port
					-e：扩展格式
					-p：显示相关的进程及PID；

				常用组合：
					-tan, -uan, -tnl, -unl, -tunlp

				传输协议tcp, udp：
					tcp：面向连接的协议；通信开始之前，要建立一个虚链路；通信完成后还要拆除连接；
					udp：无连接的协议；直接发送数据报文；

			显示接口的统计数据：
				netstat {--interfaces|-I|-i} [iface] [--all|-a] [--extend|-e] [--verbose|-v] [--program|-p] [--numeric|-n]

				所有接口：
					netstat -i
				制定接口：
					netstat -I<IFace>

		ifup/ifdown命令：
			注意：通过配置文件/etc/sysconfig/network-scripts/ifcfg-IFACE来识别接口并完成配置；

	配置主机名：

		hostname命令：
			查看：hostname
			配置：hostname HOSTNAME
				当前系统有效，重启后无效；

		hostnamectl命令(CentOS 7)：
			hostnamectl status：显示当前主机名信息；
			hostnamectl set-hostname：设定主机名，永久有效；

		配置文件：/etc/sysconfig/network
			HOSTNAME=<>

			注意：此方法的设置不会立即生效；但以后会一直有效；

	配置DNS服务器指向：

		配置文件：/etc/resolv.conf
			nameserver DNS_SERVER_IP

			如何测试(host/nslookup/dig)：
				# dig -t A FQDN
					FQDN --> IP

				# dig -x IP
					IP --> FQDN

	iproute家族：
		ip命令：
			show / manipulate routing, devices, policy routing and tunnels

			ip [ OPTIONS ] OBJECT { COMMAND | help }
				OBJECT := { link | address | route | netns }

			注意：OBJECT可简写，各OBJECT的子命令也可简写；

			ip OBJECT:

				ip link：network device configuration

					ip link set - change device attributes
						dev DEVICE：指明要管理的设备，dev关键字可省略；
						up and down；
						multicast on or multicast off：启用或禁用多播功能；
						name NAME：重命名接口；
						mtu NUMBER：设置MTU的大小默认为1500；
						netns NETNSNAME | PID：ns为namespace，用于将接口移动到指定的网络名称空间；

					ip link show - display device attributes

					ip link help - 显示简要使用帮助；

				ip-netns - process network namespace management

					ip netns [ list ]：列出所有的netns
					ip netns add NETNSNAME：创建指定的netns
					ip netns del NETNSNAME：删除指定的netns
					ip [-all] netns exec [ NETNSNAME ] command...：在指定的netns中运行命令

				ip-address - protocol address management

					ip address add - add new protocol address.
						ip addr add IFADDR dev IFACE
							[label NAME]：为额外添加的地址指明接口别名；
							[broadcast ADDRESS]：广播地址；会根据IP和NETMASK自动计算得到；
							[scope SCOPE_VALUE]：
								global：全局可用；
								link：接口可用；
								host：仅本机可用；

					ip address delete - delete protocol address
						ip addr delete IFADDR dev IFACE

					ip address show - look at protocol addresses
						[IFACE]：显示接口的地址；

					ip address flush - flush protocol addresses
						ip addr flush dev IFACE

				ip-route - routing table management

					ip route add - add new route
					ip route change - change route
					ip route replace - change or add new one
						ip route add TYPE PREFIX via GW [dev IFACE] [src SOURCE_IP]

						示例：
							# ip route add 192.168.0.0/24 via 10.0.0.1 dev eth1 src 10.0.20.100
							# ip route default via GW

					ip route delete - delete route
						ip route del TYPE PREFIX

						示例：
							# ip route del 192.168.1.0/24

					ip route show - list routes
						TYPE PREFIX
					ip route show - list routes
						TYPE PREFIX

					ip route get - get a single route
						ip route get TYPE PREFIX

						示例：ip route get 192.168.0.0/24

		ss命令：
			ss [options] [ FILTER ]
				选项：
					-t：TCP协议的相关连接
					-u：UDP相关的连接
					-w：raw socket相关的连接
					-l：监听相关的连接
					-a：所有状态的连接
					-n：数字格式
					-p：相关的程序及其PID
					-e：扩展格式信息
					-m：内存用量
					-o：计时器信息

				FILTER := [ state STATE-FILTER ] [ EXPRESSION ]

				TCP的常见状态：
					TCP FSM：
						LISTEN：监听
						ESTABLISHED：建立的连接
						FIN_WAIT_1:
						FIN_WAIT_2:
						SYN_SENT：
						SYN_RECV：
						CLOSED：

					EXPRESSION：
						dport = 
						sport = 
							示例：'(dport = :22 or sport = :22)'
								~]# ss -tan '( dport = :22 or sport = :22 )'
								~]# ss -tan state ESTABLISHED

	配置文件：
		IP/NETMASK/GW/DNF等属性的配置文件：/etc/sysconfig/network-scripts/iccfg-IFACE
			IFACE：接口名称；
		路由的相关配置文件：/etc/sysconfig/networkj-scripts/route-IFACE

		配置文件/etc/sysconfig/network-scripts/ifcfg-IFACE通过大量参数来定义接口的属性；其可通过vim等文本编辑器直接修改，也可以使用专用的命令进行修改(CentOS 6：system-config-network(setup),CentOS 7：nmtui)

			ifcfg-IFACE配置文件参数：
				DEVICE：此配置文件对应的设备的名称；
				ONBOOT：在系统引导过程中是否激活此接口；
				UUID：此设备的惟一标识；
				IPV6INIT：是否初始化IPv6；
				BOOTPROTO：激活此接口时使用什么协议来配置接口属性，常用的有dhcp、bootp、static、none
				TYPE：指明接口类型，常见的有Ethernet，Bridge；
				DNS1：第一DNS服务器指向；
				DNS2：第二DNS服务器指向；
				DOMAIN：DNS搜索域；
				IPADDR：IP地址；
				NETMASK：子网掩码；CentOS 7支持使用PREFIX以长度方式指明子网掩码；
				GATEWAY：默认网关；
				USERCTL：是否允许普通用户控制此设备；
				PEERDNS：如果BOOTPROTO的值为"dhcp"，是否允许dhcp server分配的dns服务器指向覆盖本地手动指定的DNS服务器指向；默认为允许；
				HWADDR：设备的MAC地址；

				NM_CONTROLLED：是否使用NetworkManager服务来控制接口；

			网络服务：
				network
				NetworkManager 

				管理网络服务;
					CentOS 6：service SERVICE {start|stop|restart|status}
					CentOS 7：systemctl {start|stop|restart|status} SERVICE[.service]

				配置文件修改之后，如果要生效，需要重启网络服务；
					CentOS 6：# service network restart
					CentOS 7：# systemctl restart network.service

		用到非默认网关路由：/etc/sysconfig/network-scripts/route-IFACE
			支持两种配置方式，但不可混用；
				(1)每行一个路由条目：
					TARGET via GW

				(2)每三行一个路由条目：
					ADDRESS#=TARGET
					NETMASK#=MASK
					GATEWAY#=NEXTHOP

	给接口配置多个地址：
		ip addr之外，ifconfig或配置文件都可以；

		(1)ifconfig IFACE_LABEL IPADDR/NETMASK

			IFACE_LABEL：eth0:0, eth0:1,...

		(2)为别名添加配置文件：
			DEVICE=IFACE_LABEL
			BOOTPROTO：网卡别名不支持动态获取地址；
				static,none

	nmcli命令：
		nmcli [OPTIONS...] {help | general | networking | radio | connection | device | agent | monitor} [COMMAND] [ARGUMENTS...]

		device - Show and manage network interfaces.
			COMMAND :={status | show | set | connect | reapply | modify | disconnect | delete | monitor | wifi | lldp} [ARGUMENTS...]

		connection - start, stop, and manage network connections
			COMMAND :={show | up | down | modify | add | edit | clone | delete | monitor | reload | load | import | export} [ARGUMENTS...]

			modify [--temporary] [id | uuid | path] ID {option value | [+|-]setting.property value}...

			如何修改IP地址等属性；
				# nmcli connection modify IFACE {+|-}setting.property value
					ipv4.address
					ipv4.gateway
					ipv4.dns1
					ipv4.method
						 manual

	博客作业：。。。

	课外作业：nmap, ncat, tcpdump命令；

回顾：ip命令，ss命令；配置文件；CentOS 7

	ifcfg、ip、netstat、ss
	配置文件：
		/etc/sysconfig/network-scripts/
			ifcfg-IFNAME
			route-IFNAME
	CentOS 7：nmcli, cnmtui

Linux进程及作业管理
	
	内核的功用：进程管理、文件系统、网络功能、内存管理、驱动程序、安全功能

	Process：运行中的程序的一个副本；
		存在生命周期

	Linux内核存储进程信息的固定格式：task struct
		多个任务的task structs组成的链表：task lists

	进程创建：
		init
			父子关系
			进程：都由其父进程创建
				fork(), clone()

		进程优先级：
			0-139：
				1-99：实时优先级；
				100-139：静态优先级
					数字越小，优先级越高；

				Nice值：
					-20,19

			Big O
				O(1), O(logn), O(n), O(n^2), O(2^n)

		进程内存：
			Page Frame：页框，用于存储页面数据
				存储Page

				MMU：Memory Management Unit

		IPC：Inter Process Communication
			同一主机上：
				signal
				shm
				semerphor

			不同主机上：
				rpc：remote procecure call
				socket：

		Linux内核：抢占式多任务

		进程类型：
			守护进程：daemon，在系统引导过程中启动的进程，跟终端无关的进程；
			用户进程：跟终端相关，通过终端启动的进程
				注意：也可把在前台启动的进程送往后台，以守护模式运行；

		进程状态：
			运行态：running
			就绪态：ready
			睡眠态：
				可中断：interruptable
				不可中断：uninterruptable 
			停止态：暂停于内存中，但不会被调度执行，除非手动启动之；stopped
			僵死态：zoombie

		进程的分类：
			CPU-Bound
			IO-Bound

		《Linux内核设计与实现》，《深入理解Linux内核》

	Linux系统上的进程查看及管理工具：pstree, ps, pgrep, top, htop, glances, pmao, vmstat, dstat, kill, pkill, job, bg, fg, nohup, nice, renice, killall,...

		CentOS 5：SysV init
		CentOS 6：upstart
		CentOS 7：systemd

			/sbin/init,

		pstree命令：
			pstree - display a tree of processes

		ps命令：
			/proc/：内核中的状态信息
				内核参数：
					可设置其值从而调整内核运行特性的参数；/proc/sys/
					状态变量：其用于输出内核中统计信息或状态信息，仅用于查看；

				参数：模拟成文件系统类型；

			进程：
				/proc/#：
					#：PID

			ps - report a snapshot of the current processes.

				ps [options]：
					选项有三种风格：
						1   UNIX options, which may be grouped and must be preceded by a dash.
						2   BSD options, which may be grouped and must not be used with a dash.
						3   GNU long options, which are preceded by two dashes.

					启动进程的方式：
						系统启动过程中自动启动：与终端无关的进程；
						用户通过终端启动：与终端相关的进程；

					选项：
						a：所有与终端相关的进程；
						x：所有与终端无关的进程；
						u：以用户为中心组织进程状态信息显示；

						常用组合之一：aux
							VSZ：虚拟内存集；
							RSS：Resident Size, 常驻内存集；
							STAT：
								R：running
								S：interruptable sleeping
								D：unintterupable sleeping
								T：Stopped
								Z：zombie

								+：前台进程
								l：多线程进程
								N：低优先级进程
								<：高优先级进程
								s：session leader

						-e：显示所有进程
						-f：显示完整格式的进程信息

						常用组合之二：-ef

						-F：显示完整格式的进程信息
							C：cpu utilization
							PSR：运行于哪颗CPU之上
						-H：以层级结构显示进程的相关信息；

						常用组合之三：-eFH

						常用组合之四：-eo, axo
							o field1,field2,...：自定义要显示的字段历列表，以逗号分隔；
								常用的field：pid, ni, pri, psr, pcpu, stat, comm, tty, ppid, rtprio
									ni：nice值；
									pri：priority，优先级；
									rpprio：real time priority，实时优先级；

			pgreg, pkill命令：
				pgrep,  pkill  -  look  up  or signal processes based on name and other attributes

				pgrep [options] pattern
					-u uid：effective user
					-U uid：real user
					-t TERMINAL：与指定的终端相关的进程；
					-l：显示进程名；
					-a：显示完整格式的进程名；
					-P pid：显示此进程的子进程；

			pidof命令：
				根据进程名，取其pid；

			top命令：
				top - display Linux processes

				排序：
					P：以占据CPU百分比排序；
					M：以占据内存百分比排序；
					T：累计占用CPU时间排序；

				首部信息：
					uptime信息：l命令
					tasks信息及cpu信息：t命令
					内存信息：m命令

				推出命令：q
				修改刷新时间间隔：s
				终止指定的进程：k

				选项：
					-d #：指定刷新时间间隔，默认为3秒；
					-b：以批次方式显示；
					-n #：显示多少批次；

			uptime命令：显示系统时间、运行时长及平均负载；
				过去1分钟、5分钟和15分钟的平均负载；
					等待运行的进程队列的长度；

回顾：Linux OS基础概念
			  























